From 9229c54b0ab8540070b16708ffecb8cf3229a444 Mon Sep 17 00:00:00 2001
From: Ps3itaTeam <ps3itateam@ps3ita.it>
Date: Thu, 7 Feb 2019 13:46:49 +0100
Subject: [PATCH] Added ps4 patch

---
 arch/x86/Kconfig                              |   8 +
 arch/x86/include/asm/msi.h                    |   2 +
 arch/x86/include/asm/ps4.h                    |  60 ++
 arch/x86/include/asm/setup.h                  |   6 +
 arch/x86/include/uapi/asm/bootparam.h         |   1 +
 arch/x86/kernel/apic/msi.c                    |   2 +-
 arch/x86/kernel/head64.c                      |   7 +-
 arch/x86/platform/Makefile                    |   1 +
 arch/x86/platform/ps4/Makefile                |   1 +
 arch/x86/platform/ps4/calibrate.c             | 116 +++
 arch/x86/platform/ps4/ps4.c                   |  76 ++
 drivers/Makefile                              |   1 +
 drivers/ata/ahci.c                            |  42 +-
 drivers/gpu/drm/amd/amdgpu/Makefile           |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu.h           |   3 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c    |   2 +
 .../gpu/drm/amd/amdgpu/amdgpu_connectors.c    |  44 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c    |   6 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c       |  19 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c  |  19 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c        |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_ih.c        |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c       |   6 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c     |   2 +
 drivers/gpu/drm/amd/amdgpu/atombios_dp.c      |   9 +-
 .../gpu/drm/amd/amdgpu/atombios_encoders.c    |   7 +-
 drivers/gpu/drm/amd/amdgpu/cik.c              | 318 ++++++++
 drivers/gpu/drm/amd/amdgpu/cik_sdma.c         |  55 +-
 drivers/gpu/drm/amd/amdgpu/dce_v8_0.c         |  44 +-
 drivers/gpu/drm/amd/amdgpu/dce_virtual.c      |   2 +
 drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c         | 738 ++++++++++++++++-
 drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c         |  19 +-
 drivers/gpu/drm/amd/amdgpu/ps4_bridge.c       | 758 +++++++++++++++++
 drivers/gpu/drm/amd/include/amd_shared.h      |   3 +-
 .../drm/amd/include/asic_reg/gmc/gmc_7_1_d.h  |  28 +
 drivers/gpu/drm/drm_pci.c                     |   2 +-
 drivers/gpu/drm/radeon/Makefile               |   2 +
 drivers/gpu/drm/radeon/atombios_encoders.c    |   2 +-
 drivers/gpu/drm/radeon/cik.c                  | 765 ++++++++++++++++--
 drivers/gpu/drm/radeon/cik_sdma.c             |  47 +-
 drivers/gpu/drm/radeon/cikd.h                 |  28 +-
 drivers/gpu/drm/radeon/ps4_bridge.c           | 756 +++++++++++++++++
 drivers/gpu/drm/radeon/radeon.h               |   3 +-
 drivers/gpu/drm/radeon/radeon_asic.c          |  14 +-
 drivers/gpu/drm/radeon/radeon_audio.c         |   7 +-
 drivers/gpu/drm/radeon/radeon_connectors.c    |  50 +-
 drivers/gpu/drm/radeon/radeon_device.c        |   1 +
 drivers/gpu/drm/radeon/radeon_display.c       |   2 +-
 drivers/gpu/drm/radeon/radeon_drv.c           |  16 +-
 drivers/gpu/drm/radeon/radeon_encoders.c      |  18 +
 drivers/gpu/drm/radeon/radeon_family.h        |   1 +
 drivers/gpu/drm/radeon/radeon_ib.c            |   2 +-
 drivers/gpu/drm/radeon/radeon_pm.c            |   1 +
 drivers/gpu/drm/radeon/radeon_ucode.h         |   3 +
 drivers/gpu/drm/radeon/radeon_uvd.c           |   1 +
 drivers/gpu/drm/radeon/radeon_vce.c           |   1 +
 drivers/iommu/amd_iommu_init.c                |   6 +-
 drivers/mmc/host/sdhci-pci-core.c             |  72 +-
 drivers/mmc/host/sdhci-pci.h                  |   3 +-
 drivers/net/ethernet/marvell/sky2.c           | 139 +++-
 drivers/net/ethernet/marvell/sky2.h           |   4 +-
 drivers/pci/probe.c                           |  17 +-
 drivers/ps4/Makefile                          |   9 +
 drivers/ps4/aeolia.h                          | 172 ++++
 drivers/ps4/icc/i2c.c                         | 156 ++++
 drivers/ps4/ps4-apcie-icc.c                   | 602 ++++++++++++++
 drivers/ps4/ps4-apcie-pwrbutton.c             |  69 ++
 drivers/ps4/ps4-apcie-uart.c                  |  67 ++
 drivers/ps4/ps4-apcie.c                       | 534 ++++++++++++
 drivers/usb/host/Kconfig                      |   7 +
 drivers/usb/host/Makefile                     |   1 +
 drivers/usb/host/xhci-aeolia.c                | 304 +++++++
 drivers/usb/host/xhci.c                       |  31 +-
 drivers/usb/host/xhci.h                       |   1 +
 include/linux/pci_ids.h                       |  24 +
 75 files changed, 6146 insertions(+), 205 deletions(-)
 create mode 100644 arch/x86/include/asm/ps4.h
 create mode 100644 arch/x86/platform/ps4/Makefile
 create mode 100644 arch/x86/platform/ps4/calibrate.c
 create mode 100644 arch/x86/platform/ps4/ps4.c
 create mode 100644 drivers/gpu/drm/amd/amdgpu/ps4_bridge.c
 create mode 100644 drivers/gpu/drm/radeon/ps4_bridge.c
 create mode 100644 drivers/ps4/Makefile
 create mode 100644 drivers/ps4/aeolia.h
 create mode 100644 drivers/ps4/icc/i2c.c
 create mode 100644 drivers/ps4/ps4-apcie-icc.c
 create mode 100644 drivers/ps4/ps4-apcie-pwrbutton.c
 create mode 100644 drivers/ps4/ps4-apcie-uart.c
 create mode 100644 drivers/ps4/ps4-apcie.c
 create mode 100644 drivers/usb/host/xhci-aeolia.c

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 4f393eb9745f38..a357714839587d 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -507,6 +507,14 @@ config X86_NUMACHIP
 	  Adds support for Numascale NumaChip large-SMP systems. Needed to
 	  enable more than ~168 cores.
 	  If you don't have one of these, you should say N here.
+		
+config X86_PS4
+	bool "Sony PlayStation 4"
+	depends on X86_64
+	depends on X86_EXTENDED_PLATFORM
+	depends on PCI
+	---help---
+	  Select to include support for the Sony PlayStation 4 game console.
 
 config X86_VSMP
 	bool "ScaleMP vSMP"
diff --git a/arch/x86/include/asm/msi.h b/arch/x86/include/asm/msi.h
index 25ddd0916bb2f4..154b0f6069db69 100644
--- a/arch/x86/include/asm/msi.h
+++ b/arch/x86/include/asm/msi.h
@@ -11,4 +11,6 @@ int pci_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
 
 void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc);
 
+void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg);
+
 #endif /* _ASM_X86_MSI_H */
diff --git a/arch/x86/include/asm/ps4.h b/arch/x86/include/asm/ps4.h
new file mode 100644
index 00000000000000..60ee1c4f4f1841
--- /dev/null
+++ b/arch/x86/include/asm/ps4.h
@@ -0,0 +1,60 @@
+/*
+ * ps4.h: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _ASM_X86_PS4_H
+#define _ASM_X86_PS4_H
+
+#ifdef CONFIG_X86_PS4
+
+#include <linux/irqdomain.h>
+
+#define PS4_DEFAULT_TSC_FREQ 1594000000
+
+#define EMC_TIMER_BASE 0xd0281000
+#define EMC_TIMER_VALUE 0x28
+
+extern unsigned long ps4_calibrate_tsc(void);
+
+/*
+ * The PS4 Aeolia southbridge device is a composite device containing some
+ * standard-ish, some not-so-standard, and some completely custom functions,
+ * all using special MSI handling. This function does the equivalent of
+ * pci_enable_msi_range and friends, for those devices. Only works after the
+ * Aeolia MSR routing function device (function 4) has been probed.
+ * Returns 1 or count, depending on IRQ allocation constraints, or negative on
+ * error. Assigned IRQ(s) start at dev->irq.
+ */
+extern int apcie_assign_irqs(struct pci_dev *dev, int nvec);
+extern void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs);
+
+extern int apcie_status(void);
+extern int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+			 u16 length, void *reply, u16 reply_length);
+
+
+#else
+
+static inline int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	return -ENODEV;
+}
+static inline void apcie_free_irqs(unsigned int virq, unsigned int nvec)
+{
+}
+static inline int apcie_status(void)
+{
+	return -ENODEV;
+}
+static inline int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+				u16 length, void *reply, u16 reply_length)
+{
+	return -ENODEV;
+}
+
+#endif
+#endif
diff --git a/arch/x86/include/asm/setup.h b/arch/x86/include/asm/setup.h
index ae13bc974416fd..0a81ae7e888602 100644
--- a/arch/x86/include/asm/setup.h
+++ b/arch/x86/include/asm/setup.h
@@ -59,6 +59,12 @@ extern void x86_ce4100_early_setup(void);
 static inline void x86_ce4100_early_setup(void) { }
 #endif
 
+#ifdef CONFIG_X86_PS4
+extern void x86_ps4_early_setup(void);
+#else
+static inline void x86_ps4_early_setup(void) { }
+#endif
+
 #ifndef _SETUP
 
 #include <asm/espfix.h>
diff --git a/arch/x86/include/uapi/asm/bootparam.h b/arch/x86/include/uapi/asm/bootparam.h
index afdd5ae0fcc41d..aedecf11acbb2f 100644
--- a/arch/x86/include/uapi/asm/bootparam.h
+++ b/arch/x86/include/uapi/asm/bootparam.h
@@ -219,6 +219,7 @@ enum x86_hardware_subarch {
 	X86_SUBARCH_XEN,
 	X86_SUBARCH_INTEL_MID,
 	X86_SUBARCH_CE4100,
+	X86_SUBARCH_PS4,
 	X86_NR_SUBARCHS,
 };
 
diff --git a/arch/x86/kernel/apic/msi.c b/arch/x86/kernel/apic/msi.c
index f10e7f93b0e2c0..b84d39aa7dd8a8 100644
--- a/arch/x86/kernel/apic/msi.c
+++ b/arch/x86/kernel/apic/msi.c
@@ -26,7 +26,7 @@
 
 static struct irq_domain *msi_default_domain;
 
-static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
+void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
 {
 	struct irq_cfg *cfg = irqd_cfg(data);
 
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index 45b5c6c4a55eda..a0f1092ef11bcb 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -376,6 +376,11 @@ void __init x86_64_start_reservations(char *real_mode_data)
 	default:
 		break;
 	}
-
+	/* Call the subarch specific early setup function */
+	switch (boot_params.hdr.hardware_subarch) {
+	case X86_SUBARCH_PS4:
+		x86_ps4_early_setup();
+		break;
+	}
 	start_kernel();
 }
diff --git a/arch/x86/platform/Makefile b/arch/x86/platform/Makefile
index d0e835470d01af..66bc0cf7ef25f5 100644
--- a/arch/x86/platform/Makefile
+++ b/arch/x86/platform/Makefile
@@ -10,6 +10,7 @@ obj-y	+= intel/
 obj-y	+= intel-mid/
 obj-y	+= intel-quark/
 obj-y	+= olpc/
+obj-y	+= ps4/
 obj-y	+= scx200/
 obj-y	+= sfi/
 obj-y	+= ts5500/
diff --git a/arch/x86/platform/ps4/Makefile b/arch/x86/platform/ps4/Makefile
new file mode 100644
index 00000000000000..4d5fcde3a08077
--- /dev/null
+++ b/arch/x86/platform/ps4/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_X86_PS4) += ps4.o calibrate.o
diff --git a/arch/x86/platform/ps4/calibrate.c b/arch/x86/platform/ps4/calibrate.c
new file mode 100644
index 00000000000000..c8375c797ea3dd
--- /dev/null
+++ b/arch/x86/platform/ps4/calibrate.c
@@ -0,0 +1,116 @@
+/*
+ * calibrate.c: Sony PS4 TSC/LAPIC calibration
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/jiffies.h>
+#include <asm/io.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+#include <asm/delay.h>
+#include <asm/apic.h>
+
+/* The PS4 southbridge (Aeolia) has an EMC timer that ticks at 32.768kHz,
+ * which seems to be an appropriate clock reference for calibration. Both TSC
+ * and the LAPIC timer are based on the core clock frequency and thus can be
+ * calibrated together. */
+static void __iomem *emc_timer = NULL;
+
+static __init inline u32 emctimer_read32(unsigned int reg)
+{
+	return ioread32(emc_timer + reg);
+}
+
+static __init inline void emctimer_write32(unsigned int reg, u32 val)
+{
+	iowrite32(val, emc_timer + reg);
+}
+
+static __init inline u32 emctimer_read(void)
+{
+	u32 t1, t2;
+	t1 = emctimer_read32(EMC_TIMER_VALUE);
+	while (1) {
+		t2 = emctimer_read32(EMC_TIMER_VALUE);
+		if (t1 == t2)
+			return t1;
+		t1 = t2;
+	}
+}
+
+static __init unsigned long ps4_measure_tsc_freq(void)
+{
+	unsigned long ret = 0;
+	u32 t1, t2;
+	u64 tsc1, tsc2;
+
+	// This is part of the Aeolia pcie device, but it's too early to
+	// do this in a driver.
+	emc_timer = ioremap(EMC_TIMER_BASE, 0x100);
+	if (!emc_timer)
+		goto fail;
+
+	// reset/start the timer
+	emctimer_write32(0x84, emctimer_read32(0x84) & (~0x01));
+	// udelay is not calibrated yet, so this is likely wildly off, but good
+	// enough to work.
+	udelay(300);
+	emctimer_write32(0x00, emctimer_read32(0x00) | 0x01);
+	emctimer_write32(0x84, emctimer_read32(0x84) | 0x01);
+
+	t1 = emctimer_read();
+	tsc1 = tsc2 = rdtsc();
+
+	while (emctimer_read() == t1) {
+		// 0.1s timeout should be enough
+		tsc2 = rdtsc();
+		if ((tsc2 - tsc1) > (PS4_DEFAULT_TSC_FREQ/10)) {
+			pr_warn("EMC timer is broken.\n");
+			goto fail;
+		}
+	}
+	pr_info("EMC timer started in %lld TSC ticks\n", tsc2 - tsc1);
+
+	// Wait for a tick boundary
+	t1 = emctimer_read();
+	while ((t2 = emctimer_read()) == t1);
+	tsc1 = rdtsc();
+
+	// Wait for 1024 ticks to elapse (31.25ms)
+	// We don't need to wait very long, as we are looking for transitions.
+	// At this value, a TSC uncertainty of ~50 ticks corresponds to 1ppm of
+	// clock accuracy.
+	while ((emctimer_read() - t2) < 1024);
+	tsc2 = rdtsc();
+
+	// TSC rate is 32 times the elapsed time
+	ret = (tsc2 - tsc1) * 32;
+
+	pr_info("Calibrated TSC frequency: %ld kHz\n", ret);
+fail:
+	if (emc_timer) {
+		iounmap(emc_timer);
+		emc_timer = NULL;
+	}
+	return ret;
+}
+
+unsigned long __init ps4_calibrate_tsc(void)
+{
+	unsigned long tsc_freq = ps4_measure_tsc_freq();
+
+	if (!tsc_freq) {
+		pr_warn("Unable to measure TSC frequency, assuming default.\n");
+		tsc_freq = PS4_DEFAULT_TSC_FREQ;
+	}
+
+	lapic_timer_frequency = (tsc_freq + 8 * HZ) / (16 * HZ);
+
+	return (tsc_freq + 500) / 1000;
+}
diff --git a/arch/x86/platform/ps4/ps4.c b/arch/x86/platform/ps4/ps4.c
new file mode 100644
index 00000000000000..a077df74003e76
--- /dev/null
+++ b/arch/x86/platform/ps4/ps4.c
@@ -0,0 +1,76 @@
+/*
+ * ps4.c: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/scatterlist.h>
+#include <linux/sfi.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+
+#include <asm/setup.h>
+#include <asm/mpspec_def.h>
+#include <asm/hw_irq.h>
+#include <asm/apic.h>
+#include <asm/io_apic.h>
+#include <asm/io.h>
+#include <asm/i8259.h>
+#include <asm/apb_timer.h>
+#include <asm/reboot.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+
+static bool is_ps4;
+bool apcie_initialized;
+
+/*
+ * The RTC is part of the Aeolia PCI device and will be implemented there as
+ * an RTC class device; stub these out.
+ */
+static void dummy_get_wallclock(struct timespec64 *now)
+{
+	now->tv_sec = now->tv_nsec = 0;
+}
+static int dummy_set_wallclock(const struct timespec64 *now)
+{
+	return -ENODEV;
+}
+
+/*
+ * Provide a way for generic drivers to query for the availability of the
+ * PS4 apcie driver/device, which is a dependency for them.
+ */
+int apcie_status(void)
+{
+	if (!is_ps4)
+		return -ENODEV;
+	return apcie_initialized;
+}
+EXPORT_SYMBOL_GPL(apcie_status);
+
+void icc_reboot(void);
+
+/*
+ * PS4 specific x86_init function overrides and early setup calls.
+ */
+void __init x86_ps4_early_setup(void)
+{
+	pr_info("x86_ps4_early_setup: PS4 early setup\n");
+	is_ps4 = true;
+	x86_platform.calibrate_tsc = ps4_calibrate_tsc;
+	x86_platform.get_wallclock = dummy_get_wallclock;
+	x86_platform.set_wallclock = dummy_set_wallclock;
+
+	legacy_pic = &null_legacy_pic;
+	machine_ops.emergency_restart = icc_reboot;
+}
diff --git a/drivers/Makefile b/drivers/Makefile
index 5f5ccdbad21ae0..8acdd8abfabafa 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -87,6 +87,7 @@ obj-$(CONFIG_MTD)		+= mtd/
 obj-$(CONFIG_SPI)		+= spi/
 obj-$(CONFIG_SPMI)		+= spmi/
 obj-$(CONFIG_HSI)		+= hsi/
+obj-$(CONFIG_X86_PS4)		+= ps4/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index f003e301723a4a..87e97184b6ffb8 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -50,6 +50,10 @@
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include "ahci.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #define DRV_NAME	"ahci"
 #define DRV_VERSION	"3.0"
 
@@ -568,6 +572,11 @@ static const struct pci_device_id ahci_pci_tbl[] = {
 	/* Enmotus */
 	{ PCI_DEVICE(0x1c44, 0x8000), board_ahci },
 
+	/* Sony (PS4) */
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_AEOLIA_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BELIZE_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BAIKAL_AHCI), board_ahci },
+
 	/* Generic, PCI class code for AHCI */
 	{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
 	  PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff, board_ahci },
@@ -911,7 +920,22 @@ static int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)
 	 */
 	if (pdev->dma_mask && pdev->dma_mask < DMA_BIT_MASK(32))
 		return 0;
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		rc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(31));
+		if (rc) {
+			dev_err(&pdev->dev, "31-bit DMA enable failed\n");
+			return rc;
+		}
+		rc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(31));
+		if (rc) {
+			dev_err(&pdev->dev,
+				"31-bit consistent DMA enable failed\n");
+			return rc;
+		}
+		return 0;
+	}
+#endif
 	if (using_dac &&
 	    !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {
 		rc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
@@ -1552,6 +1576,11 @@ static int ahci_init_msi(struct pci_dev *pdev, unsigned int n_ports,
 {
 	int nvec;
 
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		return apcie_assign_irqs(pdev, n_ports);
+	}
+#endif
 	if (hpriv->flags & AHCI_HFLAG_NO_MSI)
 		return -ENODEV;
 
@@ -1604,7 +1633,11 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	VPRINTK("ENTER\n");
 
 	WARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);
-
+#ifdef CONFIG_X86_PS4
+	/* This will return negative on non-PS4 platforms */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	ata_print_version_once(&pdev->dev, DRV_VERSION);
 
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
@@ -1827,6 +1860,11 @@ static void ahci_remove_one(struct pci_dev *pdev)
 {
 	pm_runtime_get_noresume(&pdev->dev);
 	ata_pci_remove_one(pdev);
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		apcie_free_irqs(pdev->irq, 1);
+	}
+#endif
 }
 
 module_pci_driver(ahci_pci_driver);
diff --git a/drivers/gpu/drm/amd/amdgpu/Makefile b/drivers/gpu/drm/amd/amdgpu/Makefile
index 567b0377e1e21e..cd4fbfedb3c7ce 100644
--- a/drivers/gpu/drm/amd/amdgpu/Makefile
+++ b/drivers/gpu/drm/amd/amdgpu/Makefile
@@ -128,7 +128,7 @@ amdgpu-$(CONFIG_COMPAT) += amdgpu_ioc32.o
 amdgpu-$(CONFIG_VGA_SWITCHEROO) += amdgpu_atpx_handler.o
 amdgpu-$(CONFIG_ACPI) += amdgpu_acpi.o
 amdgpu-$(CONFIG_MMU_NOTIFIER) += amdgpu_mn.o
-
+amdgpu-$(CONFIG_X86_PS4) += ps4_bridge.o
 include $(FULL_AMD_PATH)/powerplay/Makefile
 
 amdgpu-y += $(AMD_POWERPLAY_FILES)
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 712ad8c2bdc5d5..cd1374d6d4316e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -171,7 +171,8 @@ extern int amdgpu_cik_support;
 /* max cursor sizes (in pixels) */
 #define CIK_CURSOR_WIDTH 128
 #define CIK_CURSOR_HEIGHT 128
-
+#define LVP_CURSOR_WIDTH 64
+#define LVP_CURSOR_HEIGHT 64
 struct amdgpu_device;
 struct amdgpu_ib;
 struct amdgpu_cs_parser;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c
index f7fa7675215c27..14fae8858f6f50 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c
@@ -78,6 +78,8 @@ void amdgpu_amdkfd_device_probe(struct amdgpu_device *adev)
 	switch (adev->asic_type) {
 #ifdef CONFIG_DRM_AMDGPU_CIK
 	case CHIP_KAVERI:
+	case CHIP_GLADIUS:
+	case CHIP_LIVERPOOL:
 		kfd2kgd = amdgpu_amdkfd_gfx_7_get_functions();
 		break;
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
index 1eff36a8759581..e1e4e4e6a13b39 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
@@ -1517,7 +1517,29 @@ static const struct drm_connector_funcs amdgpu_connector_dp_funcs = {
 	.destroy = amdgpu_connector_destroy,
 	.force = amdgpu_connector_dvi_force,
 };
+#ifdef CONFIG_X86_PS4
+int ps4_bridge_get_modes(struct drm_connector *connector);
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+			struct drm_display_mode *mode);
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+					  bool force);
 
+
+static const struct drm_connector_helper_funcs amdgpu_ps4_dp_connector_helper_funcs = {
+	.get_modes = ps4_bridge_get_modes,
+	.mode_valid = ps4_bridge_mode_valid,
+	.best_encoder = amdgpu_connector_dvi_encoder,
+};
+
+static const struct drm_connector_funcs amdgpu_ps4_dp_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = ps4_bridge_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	//.set_property = amdgpu_connector_set_property,
+	.destroy = amdgpu_connector_destroy,
+	.force = amdgpu_connector_dvi_force,
+};
+#endif
 static const struct drm_connector_funcs amdgpu_connector_edp_funcs = {
 	.dpms = drm_helper_connector_dpms,
 	.detect = amdgpu_connector_dp_detect,
@@ -1547,6 +1569,7 @@ amdgpu_connector_add(struct amdgpu_device *adev,
 	uint32_t subpixel_order = SubPixelNone;
 	bool shared_ddc = false;
 	bool is_dp_bridge = false;
+	bool is_ps4_bridge = false;
 	bool has_aux = false;
 
 	if (connector_type == DRM_MODE_CONNECTOR_Unknown)
@@ -1590,7 +1613,16 @@ amdgpu_connector_add(struct amdgpu_device *adev,
 	amdgpu_connector = kzalloc(sizeof(struct amdgpu_connector), GFP_KERNEL);
 	if (!amdgpu_connector)
 		return;
-
+	/* Liverpool (PS4) has an DP bridge which needs a special driver, and
+	 * a fake HDMI port that doesn't really exist. */
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		if (connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
+			is_dp_bridge = true;
+		} else {
+			return;
+		}
+	}
 	connector = &amdgpu_connector->base;
 
 	amdgpu_connector->connector_id = connector_id;
@@ -1641,10 +1673,20 @@ amdgpu_connector_add(struct amdgpu_device *adev,
 		case DRM_MODE_CONNECTOR_HDMIA:
 		case DRM_MODE_CONNECTOR_HDMIB:
 		case DRM_MODE_CONNECTOR_DisplayPort:
+		if (is_ps4_bridge) {
 			drm_connector_init(dev, &amdgpu_connector->base,
 					   &amdgpu_connector_dp_funcs, connector_type);
 			drm_connector_helper_add(&amdgpu_connector->base,
 						 &amdgpu_connector_dp_helper_funcs);
+		} else {
+			drm_connector_init(dev, &amdgpu_connector->base,
+						&amdgpu_ps4_dp_connector_funcs, connector_type);
+			drm_connector_helper_add(&amdgpu_connector->base,
+						&amdgpu_ps4_dp_connector_helper_funcs);
+						//&amdgpu_connector_dp_helper_funcs);
+						
+						
+		}
 			drm_object_attach_property(&amdgpu_connector->base.base,
 						      adev->mode_info.underscan_property,
 						      UNDERSCAN_OFF);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index bc746a6e0eccf2..5c92b41a03350b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -75,6 +75,8 @@ static const char *amdgpu_asic_name[] = {
 	"BONAIRE",
 	"KAVERI",
 	"KABINI",
+	"LIVERPOOL",
+	"GLADIUS",
 	"HAWAII",
 	"MULLINS",
 	"TOPAZ",
@@ -1382,6 +1384,8 @@ static int amdgpu_device_parse_gpu_info_fw(struct amdgpu_device *adev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 #endif
 	default:
 		return 0;
@@ -1491,6 +1495,8 @@ static int amdgpu_early_init(struct amdgpu_device *adev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		if ((adev->asic_type == CHIP_BONAIRE) || (adev->asic_type == CHIP_HAWAII))
 			adev->family = AMDGPU_FAMILY_CI;
 		else
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index 4dd68d8213538e..9dcb4f0f3d31ab 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
@@ -46,6 +46,9 @@
 
 #include "amdgpu_amdkfd.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
 /*
  * KMS wrapper.
  * - 3.0.0 - initial driver
@@ -449,6 +452,13 @@ static const struct pci_device_id pciidlist[] = {
 	{0x1002, 0x985D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
+	/* liverpool */
+	{0x1002, 0x9920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9922, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9923, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	/* gladius */
+	{0x1002, 0x9924, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_GLADIUS|AMD_IS_APU},
+
 #endif
 	/* topaz */
 	{0x1002, 0x6900, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},
@@ -577,6 +587,15 @@ static int amdgpu_pci_probe(struct pci_dev *pdev,
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_X86_PS4
+	/* On the PS4 (Liverpool graphics) we have a hard dependency on the
+	 * Aeolia driver to set up the HDMI encoder which is connected to it,
+	 * so defer probe until it is ready. This test passes if this isn't
+	 * a PS4 (returns -ENODEV).
+	 */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	dev = drm_dev_alloc(&kms_driver, &pdev->dev);
 	if (IS_ERR(dev))
 		return PTR_ERR(dev);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
index 94138abe093b1a..319909a00b969e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
@@ -31,6 +31,22 @@
 #include "atom.h"
 #include "atombios_encoders.h"
 
+#ifdef CONFIG_X86_PS4
+int ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder);
+
+static void amdgpu_maybe_add_bridge(struct drm_connector *connector,
+				    struct drm_encoder *encoder)
+{
+	struct drm_device *dev = connector->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		ps4_bridge_register(connector, encoder);
+	}
+}
+#endif
+
 void
 amdgpu_link_encoder_connector(struct drm_device *dev)
 {
@@ -46,6 +62,9 @@ amdgpu_link_encoder_connector(struct drm_device *dev)
 		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 			amdgpu_encoder = to_amdgpu_encoder(encoder);
 			if (amdgpu_encoder->devices & amdgpu_connector->devices) {
+#ifdef CONFIG_X86_PS4
+				amdgpu_maybe_add_bridge(connector, encoder);
+#endif
 				drm_mode_connector_attach_encoder(connector, encoder);
 				if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
 					amdgpu_atombios_encoder_init_backlight(amdgpu_encoder, connector);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c
index cd84bd0b1eafdc..76609c3de95c71 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c
@@ -343,7 +343,7 @@ int amdgpu_ib_ring_tests(struct amdgpu_device *adev)
 		tmo_gfx = 8 * AMDGPU_IB_TEST_TIMEOUT;
 	}
 
-	for (i = 0; i < AMDGPU_MAX_RINGS; ++i) {
+	for (i = 0; i < 1; ++i) {
 		struct amdgpu_ring *ring = adev->rings[i];
 		long tmo;
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ih.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ih.c
index 3ab4c65ecc8b4e..3ead7c82d06126 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ih.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ih.c
@@ -161,7 +161,7 @@ int amdgpu_ih_process(struct amdgpu_device *adev)
 	if (atomic_xchg(&adev->irq.ih.lock, 1))
 		return IRQ_NONE;
 
-	DRM_DEBUG("%s: rptr %d, wptr %d\n", __func__, adev->irq.ih.rptr, wptr);
+	//DRM_DEBUG("%s: rptr %d, wptr %d\n", __func__, adev->irq.ih.rptr, wptr);
 
 	/* Order reading of wptr vs. reading of IH ring data */
 	rmb();
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c
index 538e5f27d12058..0fabe4421f854a 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c
@@ -386,9 +386,13 @@ void amdgpu_irq_dispatch(struct amdgpu_device *adev,
 
 		src = adev->irq.client[client_id].sources[src_id];
 		if (!src) {
-			DRM_DEBUG("Unhandled interrupt src_id: %d\n", src_id);
+			//DRM_DEBUG("Unhandled interrupt src_id: %d\n", src_id);
 			return;
 		}
+		else
+		{
+			//DRM_DEBUG("Interrupt src_id: %d client_id: %d\n", src_id, client_id);
+		}
 
 		r = src->funcs->process(adev, src, entry);
 		if (r)
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
index 684769c9a48e2d..4ad6d0c31ba97f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
@@ -256,6 +256,8 @@ amdgpu_ucode_get_load_type(struct amdgpu_device *adev, int load_type)
 	case CHIP_KABINI:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return AMDGPU_FW_LOAD_DIRECT;
 #endif
 	case CHIP_TOPAZ:
diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
index f81068ba4cc67c..ac74cec17d3b25 100644
--- a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
+++ b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
@@ -261,12 +261,19 @@ static int amdgpu_atombios_dp_get_dp_link_config(struct drm_connector *connector
 		amdgpu_atombios_dp_convert_bpc_to_bpp(amdgpu_connector_get_monitor_bpc(connector));
 	static const unsigned link_rates[3] = { 162000, 270000, 540000 };
 	unsigned max_link_rate = drm_dp_max_link_rate(dpcd);
+	unsigned min_lane_num = 1;
 	unsigned max_lane_num = drm_dp_max_lane_count(dpcd);
 	unsigned lane_num, i, max_pix_clock;
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct drm_device *dev = amdgpu_connector->base.dev;
+	struct amdgpu_device *adev = dev->dev_private;
 
+	/* Liverpool is always connected to an encoder that needs 4 lanes */
+	if (adev->asic_type == CHIP_LIVERPOOL)
+			min_lane_num = 4;
 	if (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) ==
 	    ENCODER_OBJECT_ID_NUTMEG) {
-		for (lane_num = 1; lane_num <= max_lane_num; lane_num <<= 1) {
+		for (lane_num = min_lane_num; lane_num <= max_lane_num; lane_num <<= 1) {
 			max_pix_clock = (lane_num * 270000 * 8) / bpp;
 			if (max_pix_clock >= pix_clock) {
 				*dp_lanes = lane_num;
diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
index 2af26d2da12779..21f8fbfc2f2456 100644
--- a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
+++ b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
@@ -444,9 +444,11 @@ int amdgpu_atombios_encoder_get_encoder_mode(struct drm_encoder *encoder)
 	struct drm_connector *connector;
 	struct amdgpu_connector *amdgpu_connector;
 	struct amdgpu_connector_atom_dig *dig_connector;
-
+	struct drm_device *dev = encoder->dev;
+	struct amdgpu_device *adev = dev->dev_private;
 	/* dp bridges are always DP */
-	if (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)
+	if (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE ||
+	adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
 		return ATOM_ENCODER_MODE_DP;
 
 	/* DVO is always DVO */
@@ -2152,4 +2154,3 @@ amdgpu_atombios_encoder_get_dig_info(struct amdgpu_encoder *amdgpu_encoder)
 
 	return dig;
 }
-
diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 567c4a5cf90cc2..d0f602318a2ba4 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -747,6 +747,206 @@ static const u32 godavari_golden_registers[] =
 	0xc24d, 0xffffffff, 0x00000000
 };
 
+static const u32 liverpool_golden_common_registers[] =
+{
+		0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+		0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+		0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+		0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1 */
+		0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+		0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3*/
+		0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+		0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5 */
+		0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+		0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+		0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+		0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+		0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+		0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+		0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+};
+
+static const u32 liverpool_golden_registers[] =
+{
+	0x3108, 0xffffffff, 0xfffffffc, /* RLC_CGTT_MGCG_OVERRIDE */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	/* These are all setting OFF_HYSTERESIS = 0x10 */
+	0xf0a8, 0xffffffff, 0x00000100, /* CB_CGTT_SCLK_CTRL */
+	0xf082, 0xffffffff, 0x00000100, /* CGTT_BCI_CLK_CTRL */
+	0xf0b0, 0xffffffff, 0x00000100, /* CGTT_CP_CLK_CTRL */
+	0xf0b2, 0xffffffff, 0x00000100, /* CGTT_CPC_CLK_CTRL */
+	0xf0b1, 0xffffffff, 0x00000100, /* CGTT_CPF_CLK_CTRL */
+	0x1579, 0xffffffff, 0x00600100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf0a0, 0xffffffff, 0x00000100, /* CGTT_GDS_CLK_CTRL */
+	0xf085, 0xffffffff, 0x06000100, /* CGTT_IA_CLK_CTRL */
+	0xf088, 0xffffffff, 0x00000100, /* CGTT_PA_CLK_CTRL */
+	0xf086, 0xffffffff, 0x06000100, /* CGTT_WD_CLK_CTRL */
+	0xf081, 0xffffffff, 0x00000100, /* CGTT_PC_CLK_CTRL */
+	0xf0b8, 0xffffffff, 0x00000100, /* CGTT_RLC_CLK_CTRL */
+	0xf089, 0xffffffff, 0x00000100, /* CGTT_SC_CLK_CTRL */
+	0xf080, 0xffffffff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0xf08c, 0xffffffff, 0x00000100, /* CGTT_SQ_CLK_CTRL */
+	0xf08d, 0xffffffff, 0x00000100, /* CGTT_SQG_CLK_CTRL */
+	0xf094, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL0 */
+	0xf095, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL1 */
+	0xf096, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL2 */
+	0xf097, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL3 */
+	0xf098, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL4 */
+	0xf09f, 0xffffffff, 0x00000100, /* CGTT_TCI_CLK_CTRL */
+	0xf09e, 0xffffffff, 0x00000100, /* CGTT_TCP_CLK_CTRL */
+	0xf084, 0xffffffff, 0x06000100, /* CGTT_VGT_CLK_CTRL */
+	0xf0a4, 0xffffffff, 0x00000100, /* DB_CGTT_CLK_CTRL_0 */
+	0xf09d, 0xffffffff, 0x00000100, /* TA_CGTT_CTRL */
+	0xf0ad, 0xffffffff, 0x00000100, /* TCA_CGTT_SCLK_CTRL */
+	0xf0ac, 0xffffffff, 0x00000100, /* TCC_CGTT_SCLK_CTRL */
+	0xf09c, 0xffffffff, 0x00000100, /* TD_CGTT_CTRL */
+	/* */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	0xf008, 0xffffffff, 0x00010000, /* CGTS_CU0_SP0_CTRL_REG */
+	0xf009, 0xffffffff, 0x00030002, /* CGTS_CU0_LDS_SQ_CTRL_REG */
+	0xf00a, 0xffffffff, 0x00040007, /* CGTS_CU0_TA_SQC_CTRL_REG */
+	0xf00b, 0xffffffff, 0x00060005, /* CGTS_CU0_SP1_CTRL_REG */
+	0xf00c, 0xffffffff, 0x00090008, /* CGTS_CU0_TD_TCP_CTRL_REG */
+	0xf00d, 0xffffffff, 0x00010000, /* CGTS_CU1_SP0_CTRL_REG */
+	0xf00e, 0xffffffff, 0x00030002, /* CGTS_CU1_LDS_SQ_CTRL_REG */
+	0xf00f, 0xffffffff, 0x00040007, /* CGTS_CU1_TA_CTRL_REG */
+	0xf010, 0xffffffff, 0x00060005, /* CGTS_CU1_SP1_CTRL_REG */
+	0xf011, 0xffffffff, 0x00090008, /* CGTS_CU1_TD_TCP_CTRL_REG */
+	0xf012, 0xffffffff, 0x00010000, /* CGTS_CU2_SP0_CTRL_REG */
+	0xf013, 0xffffffff, 0x00030002, /* CGTS_CU2_LDS_SQ_CTRL_REG */
+	0xf014, 0xffffffff, 0x00040007, /* CGTS_CU2_TA_CTRL_REG */
+	0xf015, 0xffffffff, 0x00060005, /* CGTS_CU2_SP1_CTRL_REG */
+	0xf016, 0xffffffff, 0x00090008, /* CGTS_CU2_TD_TCP_CTRL_REG */
+	0xf017, 0xffffffff, 0x00010000, /* CGTS_CU3_SP0_CTRL_REG */
+	0xf018, 0xffffffff, 0x00030002, /* CGTS_CU3_LDS_SQ_CTRL_REG */
+	0xf019, 0xffffffff, 0x00040007, /* CGTS_CU3_TA_SQC_CTRL_REG */
+	0xf01a, 0xffffffff, 0x00060005, /* CGTS_CU3_SP1_CTRL_REG */
+	0xf01b, 0xffffffff, 0x00090008, /* CGTS_CU3_TD_TCP_CTRL_REG */
+	0xf01c, 0xffffffff, 0x00010000, /* CGTS_CU4_SP0_CTRL_REG */
+	0xf01d, 0xffffffff, 0x00030002, /* CGTS_CU4_LDS_SQ_CTRL_REG */
+	0xf01e, 0xffffffff, 0x00040007, /* CGTS_CU4_TA_CTRL_REG */
+	0xf01f, 0xffffffff, 0x00060005, /* CGTS_CU4_SP1_CTRL_REG */
+	0xf020, 0xffffffff, 0x00090008, /* CGTS_CU4_TD_TCP_CTRL_REG */
+	0xf021, 0xffffffff, 0x00010000, /* CGTS_CU5_SP0_CTRL_REG */
+	0xf022, 0xffffffff, 0x00030002, /* CGTS_CU5_LDS_SQ_CTRL_REG */
+	0xf023, 0xffffffff, 0x00040007, /* CGTS_CU5_TA_CTRL_REG */
+	0xf024, 0xffffffff, 0x00060005, /* CGTS_CU5_SP1_CTRL_REG */
+	0xf025, 0xffffffff, 0x00090008, /* CGTS_CU5_TD_TCP_CTRL_REG */
+	0xf026, 0xffffffff, 0x00010000, /* CGTS_CU6_SP0_CTRL_REG */
+	0xf027, 0xffffffff, 0x00030002, /* CGTS_CU6_LDS_SQ_CTRL_REG */
+	0xf028, 0xffffffff, 0x00040007, /* CGTS_CU6_TA_SQC_CTRL_REG */
+	0xf029, 0xffffffff, 0x00060005, /* CGTS_CU6_SP1_CTRL_REG */
+	0xf02a, 0xffffffff, 0x00090008, /* CGTS_CU6_TD_TCP_CTRL_REG */
+	0xf02b, 0xffffffff, 0x00010000, /* CGTS_CU7_SP0_CTRL_REG */
+	0xf02c, 0xffffffff, 0x00030002, /* CGTS_CU7_LDS_SQ_CTRL_REG */
+	0xf02d, 0xffffffff, 0x00040007, /* CGTS_CU7_TA_SQC_CTRL_REG */
+	0xf02e, 0xffffffff, 0x00060005, /* CGTS_CU7_SP1_CTRL_REG */
+	0xf02f, 0xffffffff, 0x00090008, /* CGTS_CU7_TD_TCP_CTRL_REG */
+	0xf030, 0xffffffff, 0x00010000, /* CGTS_CU8_SP0_CTRL_REG */
+	0xf031, 0xffffffff, 0x00030002, /* CGTS_CU8_LDS_SQ_CTRL_REG */
+	0xf032, 0xffffffff, 0x00040007, /* CGTS_CU8_TA_CTRL_REG */
+	0xf033, 0xffffffff, 0x00060005, /* CGTS_CU8_SP1_CTRL_REG */
+	0xf034, 0xffffffff, 0x00090008, /* CGTS_CU8_TD_TCP_CTRL_REG */
+	0xf035, 0xffffffff, 0x00010000, /* CGTS_CU9_SP0_CTRL_REG */
+	0xf036, 0xffffffff, 0x00030002, /* CGTS_CU9_LDS_SQ_CTRL_REG */
+	0xf037, 0xffffffff, 0x00040007, /* CGTS_CU9_TA_CTRL_REG */
+	0xf038, 0xffffffff, 0x00060005, /* CGTS_CU9_SP1_CTRL_REG */
+	0xf039, 0xffffffff, 0x00090008, /* CGTS_CU9_TD_TCP_CTRL_REG */
+	0xf000, 0xffffffff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x21c2, 0xffffffff, 0x00900100, /* CP_RB_WPTR_POLL_CNTL */
+	0x3109, 0xffffffff, 0x0020003f, /* RLC_CGCG_CGLS_CTRL */
+	0x2684, 0x00210000, 0x00018208, /* CB_HW_CONTROL */
+	0xf000, 0xffff1fff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0xf003, 0xffff0001, 0xff000000, /* CGTS_TCC_DISABLE */
+	0xf004, 0xffff0000, 0xff000000, /* CGTS_USER_TCC_DISABLE */
+	0x1579, 0xff607fff, 0xfc000100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf080, 0xfdfc0fff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x1bb6, 0x00010000, 0x00010000, /* CRTC_DOUBLE_BUFFER_CONTROL */
+	0x260d, 0xf00fffff, 0x00004400, /* DB_DEBUG2 */
+	0x16ec, 0x000000f0, 0x00000070, /* FBC_DEBUG_COMP */
+	0x263e, 0x73773777, 0x12011003, /* GB_ADDR_CONFIG */
+	0xbd2, 0x73773777, 0x12010001, /* HDP_ADDR_CONFIG */
+	0x2285, 0xf000003f, 0x00000007, /* PA_CL_ENHANCE */
+	0x22fc, 0x00000001, 0x00000001, /* PA_SC_ENHANCE */
+	0x22c9, 0xffffffff, 0x00ffffff, /* PA_SC_FORCE_EOV_MAX_CNTS */
+	0xc281, 0x0000ff0f, 0x00000000, /* PA_SC_LINE_STIPPLE_STATE */
+	0xa293, 0x07ffffff, 0x06000000, /* PA_SC_MODE_CNTL_1 */
+	0x30df, 0xffffffff, 0x00000b00, /* RLC_PG_DELAY_2 */
+	0x136, 0x00000fff, 0x00000100, /* SCLK_CGTT_BLK_CTRL_REG */
+	0xf9e, 0x00000001, 0x00000002, /* SEM_CHICKEN_BITS */
+	0x31da, 0x00000008, 0x00000008, /* SPI_RESET_DEBUG */
+	0x2300, 0x000000ff, 0x00000001, /* SQ_CONFIG */
+	0x2542, 0x00010000, 0x00010000, /* TA_CNTL_AUX */
+	0x2b03, 0xffffffff, 0x76325410, /* TCP_CHAN_STEER_LO */
+	0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1  */
+	0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3 */
+	0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5*/
+	0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+};
+
+static const u32 gladius_golden_common_registers[] =
+{
+	mmATC_MISC_CG, 0x000c0fc0, 0x000c0200,
+	mmCB_HW_CONTROL, 0x0001f3cf, 0x00007208,	// 0x2684
+	mmCB_HW_CONTROL_2, 0x0f000000, 0x0f000000,
+	mmCB_HW_CONTROL_3, 0x000001ff, 0x00000040,
+	mmDB_DEBUG2, 0xf00fffff, 0x00000400,
+	mmPA_SC_ENHANCE, 0xffffffff, 0x20000001,
+	mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,
+	mmPA_SC_RASTER_CONFIG, 0x3f3fffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0x0000003f, 0x0000002e,
+	mmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0020003c, //0x0001003c,
+	0xec9d, 0xffffffff, 0x0001003c,//mmRLC_CGCG_CGLS_CTRL_3D, 0xffffffff, 0x0001003c,
+	mmSQ_CONFIG, 0x07f80000, 0x07180000,
+	mmTA_CNTL_AUX, 0x000f000f, 0x000b0000,
+	mmTCC_CTRL, 0x00100000, 0xf31fff7f,
+	mmTCP_ADDR_CONFIG, 0x000003ff, 0x000000f7,
+	mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000,
+	mmVGT_RESET_DEBUG, 0x00000004, 0x00000004,
+	mmDCI_CLK_CNTL, 0x00000080, 0x00000000,
+	mmFBC_DEBUG_COMP, 0x000000f0, 0x00000070,
+	mmFBC_MISC, 0x9f313fff, 0x14302008,
+	mmHDMI_CONTROL, 0x313f031f, 0x00000011,
+};
+
+static const u32 gladius_golden_registers[] =
+{
+	mmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,
+	mmPA_SC_RASTER_CONFIG, 0xffffffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x0000002e,
+	mmGB_ADDR_CONFIG, 0xffffffff, 0x22011003, //0x22011003,
+	mmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,
+	mmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+
+};
+
+static const u32 gladius_mgcg_cgcg_init[] =
+{
+	0x0000313a, 0xffffffff, 0x00000003,
+	0x00003079, 0xffffffff, 0x00020201,
+	0x00003108, 0xffffffff, 0xfffffffd,
+	0x0000c200, 0xffffffff, 0xe0000000,
+	0x0000311d, 0xffffffff, 0xffffffff,
+	0x0000311e, 0xffffffff, 0xffffffff,
+	0x0000311f, 0xffffffff, 0x004000ff,
+	0x0000313a, 0xffffffff, 0x00000001,
+};
+
 static void cik_init_golden_registers(struct amdgpu_device *adev)
 {
 	/* Some of the registers might be dependent on GRBM_GFX_INDEX */
@@ -823,6 +1023,31 @@ static void cik_init_golden_registers(struct amdgpu_device *adev)
 						 hawaii_golden_spm_registers,
 						 (const u32)ARRAY_SIZE(hawaii_golden_spm_registers));
 		break;
+	case CHIP_LIVERPOOL:
+		/*amdgpu_program_register_sequence(adev,
+						 liverpool_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(liverpool_mgcg_cgcg_init));*/
+		amdgpu_program_register_sequence(adev,
+						 liverpool_golden_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_registers));
+		amdgpu_program_register_sequence(adev,
+						 liverpool_golden_common_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_common_registers));
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_program_register_sequence(adev,
+						 gladius_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(gladius_mgcg_cgcg_init));
+		amdgpu_program_register_sequence(adev,
+						 gladius_golden_registers,
+						 (const u32)ARRAY_SIZE(gladius_golden_registers));
+		amdgpu_program_register_sequence(adev,
+						 gladius_golden_common_registers,
+						 (const u32)ARRAY_SIZE(gladius_golden_common_registers));
+		amdgpu_program_register_sequence(adev,
+						 hawaii_golden_spm_registers,
+						 (const u32)ARRAY_SIZE(hawaii_golden_spm_registers));
+		break;
 	default:
 		break;
 	}
@@ -1779,6 +2004,63 @@ static int cik_common_early_init(void *handle)
 		} else
 			adev->external_rev_id = adev->rev_id + 0xa1;
 		break;
+		case CHIP_LIVERPOOL:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				/*AMD_CG_SUPPORT_GFX_CGCG |*/
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+				  AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+				  AMD_PG_SUPPORT_CP |
+				  AMD_PG_SUPPORT_GDS |
+				  AMD_PG_SUPPORT_RLC_SMU_HS |
+				  AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x61;
+			break;
+
+		case CHIP_GLADIUS:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				AMD_CG_SUPPORT_GFX_CGCG |
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+					AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+					AMD_PG_SUPPORT_CP |
+					AMD_PG_SUPPORT_GDS |
+					AMD_PG_SUPPORT_RLC_SMU_HS |
+					AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x61;
+			break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
@@ -1950,6 +2232,42 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block);
 		amdgpu_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
+	case CHIP_LIVERPOOL:
+		amdgpu_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+			amdgpu_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+			amdgpu_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
diff --git a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
index 11beef7c595f2d..7110e79fbc1bbd 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
@@ -54,17 +54,20 @@ static void cik_sdma_set_buffer_funcs(struct amdgpu_device *adev);
 static void cik_sdma_set_vm_pte_funcs(struct amdgpu_device *adev);
 static int cik_sdma_soft_reset(void *handle);
 
-MODULE_FIRMWARE("radeon/bonaire_sdma.bin");
-MODULE_FIRMWARE("radeon/bonaire_sdma1.bin");
-MODULE_FIRMWARE("radeon/hawaii_sdma.bin");
-MODULE_FIRMWARE("radeon/hawaii_sdma1.bin");
-MODULE_FIRMWARE("radeon/kaveri_sdma.bin");
-MODULE_FIRMWARE("radeon/kaveri_sdma1.bin");
-MODULE_FIRMWARE("radeon/kabini_sdma.bin");
-MODULE_FIRMWARE("radeon/kabini_sdma1.bin");
-MODULE_FIRMWARE("radeon/mullins_sdma.bin");
-MODULE_FIRMWARE("radeon/mullins_sdma1.bin");
-
+MODULE_FIRMWARE("amdgpu/bonaire_sdma.bin");
+MODULE_FIRMWARE("amdgpu/bonaire_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/hawaii_sdma.bin");
+MODULE_FIRMWARE("amdgpu/hawaii_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/kaveri_sdma.bin");
+MODULE_FIRMWARE("amdgpu/kaveri_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/kabini_sdma.bin");
+MODULE_FIRMWARE("amdgpu/kabini_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/mullins_sdma.bin");
+MODULE_FIRMWARE("amdgpu/mullins_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_sdma.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma1.bin");
 u32 amdgpu_cik_gpu_check_soft_reset(struct amdgpu_device *adev);
 
 
@@ -127,14 +130,20 @@ static int cik_sdma_init_microcode(struct amdgpu_device *adev)
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
 	for (i = 0; i < adev->sdma.num_instances; i++) {
 		if (i == 0)
-			snprintf(fw_name, sizeof(fw_name), "radeon/%s_sdma.bin", chip_name);
+			snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_sdma.bin", chip_name);
 		else
-			snprintf(fw_name, sizeof(fw_name), "radeon/%s_sdma1.bin", chip_name);
+			snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_sdma1.bin", chip_name);
 		err = request_firmware(&adev->sdma.instance[i].fw, fw_name, adev->dev);
 		if (err)
 			goto out;
@@ -642,11 +651,20 @@ static int cik_sdma_ring_test_ring(struct amdgpu_ring *ring)
 		amdgpu_wb_free(adev, index);
 		return r;
 	}
-	amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
-	amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
-	amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
-	amdgpu_ring_write(ring, 1); /* number of DWs to follow */
-	amdgpu_ring_write(ring, 0xDEADBEEF);
+	/* The SDMA_OPCODE_WRITE opcode is broken in the ring on Liverpool */
+	if (adev->asic_type == CHIP_LIVERPOOL) {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0, SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+		amdgpu_ring_write(ring, 4); /* number of bytes */
+	} else {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 1); /* number of DWs to follow */
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+	}
 	amdgpu_ring_commit(ring);
 
 	for (i = 0; i < adev->usec_timeout; i++) {
@@ -781,7 +799,6 @@ static void cik_sdma_vm_write_pte(struct amdgpu_ib *ib, uint64_t pe,
 				  uint32_t incr)
 {
 	unsigned ndw = count * 2;
-
 	ib->ptr[ib->length_dw++] = SDMA_PACKET(SDMA_OPCODE_WRITE,
 		SDMA_WRITE_SUB_OPCODE_LINEAR, 0);
 	ib->ptr[ib->length_dw++] = lower_32_bits(pe);
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
index 9cf14b8b2db9b5..682dfb837446d1 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
@@ -448,8 +448,10 @@ static int dce_v8_0_get_num_crtc(struct amdgpu_device *adev)
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
 		num_crtc = 6;
 		break;
+	case CHIP_LIVERPOOL:
 	case CHIP_KAVERI:
 		num_crtc = 4;
 		break;
@@ -1143,8 +1145,9 @@ static void dce_v8_0_bandwidth_update(struct amdgpu_device *adev)
 	struct drm_display_mode *mode = NULL;
 	u32 num_heads = 0, lb_size;
 	int i;
-
-	amdgpu_update_display_priority(adev);
+	// FIXME PS4: this stuff is broken
+	return;
+	//amdgpu_display_update_priority(adev);
 
 	for (i = 0; i < adev->mode_info.num_crtc; i++) {
 		if (adev->mode_info.crtcs[i]->base.enabled)
@@ -1438,6 +1441,8 @@ static int dce_v8_0_audio_init(struct amdgpu_device *adev)
 	else if ((adev->asic_type == CHIP_BONAIRE) ||
 		 (adev->asic_type == CHIP_HAWAII))/* BN/HW: 6 streams, 7 endpoints */
 		adev->mode_info.audio.num_pins = 7;
+		else if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) /* LVP: 3 streams, 3 endpoints (?) */
+			adev->mode_info.audio.num_pins = 3;
 	else
 		adev->mode_info.audio.num_pins = 3;
 
@@ -1452,7 +1457,13 @@ static int dce_v8_0_audio_init(struct amdgpu_device *adev)
 		adev->mode_info.audio.pin[i].id = i;
 		/* disable audio.  it will be set up later */
 		/* XXX remove once we switch to ip funcs */
-		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		//dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		/* Liverpool pin 2 is S/PDIF and should always be available */
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+
 	}
 
 	return 0;
@@ -2025,7 +2036,8 @@ static int dce_v8_0_crtc_do_set_base(struct drm_crtc *crtc,
 	}
 
 	/* Bytes per pixel may have changed */
-	dce_v8_0_bandwidth_update(adev);
+	if (adev->asic_type != CHIP_LIVERPOOL && adev->asic_type != CHIP_GLADIUS)
+		dce_v8_0_bandwidth_update(adev);
 
 	return 0;
 }
@@ -2639,12 +2651,17 @@ static int dce_v8_0_crtc_init(struct amdgpu_device *adev, int index)
 	drm_mode_crtc_set_gamma_size(&amdgpu_crtc->base, 256);
 	amdgpu_crtc->crtc_id = index;
 	adev->mode_info.crtcs[index] = amdgpu_crtc;
-
-	amdgpu_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
-	amdgpu_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
-	adev->ddev->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
-	adev->ddev->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
-
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		amdgpu_crtc->max_cursor_width = 64;
+		amdgpu_crtc->max_cursor_height = 64;
+		adev->ddev->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+		adev->ddev->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	}
+	else
+	{
+		adev->ddev->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+		adev->ddev->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	}
 	amdgpu_crtc->crtc_offset = crtc_offsets[amdgpu_crtc->crtc_id];
 
 	amdgpu_crtc->pll_id = ATOM_PPLL_INVALID;
@@ -2671,10 +2688,12 @@ static int dce_v8_0_early_init(void *handle)
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
 		break;
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 7;
 		break;
@@ -2683,6 +2702,7 @@ static int dce_v8_0_early_init(void *handle)
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6; /* ? */
 		break;
+
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
@@ -2793,6 +2813,10 @@ static int dce_v8_0_hw_init(void *handle)
 
 	for (i = 0; i < adev->mode_info.audio.num_pins; i++) {
 		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
 	}
 
 	dce_v8_0_pageflip_interrupt_init(adev);
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
index f3f93b6b51ef02..3841325e8461e3 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
@@ -462,6 +462,8 @@ static int dce_virtual_hw_init(void *handle)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		dce_v8_0_disable_dce(adev);
 		break;
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
index 6f76b26464658d..ad1ed22574d999 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
@@ -55,36 +55,50 @@ static void gfx_v7_0_set_ring_funcs(struct amdgpu_device *adev);
 static void gfx_v7_0_set_irq_funcs(struct amdgpu_device *adev);
 static void gfx_v7_0_set_gds_init(struct amdgpu_device *adev);
 
-MODULE_FIRMWARE("radeon/bonaire_pfp.bin");
-MODULE_FIRMWARE("radeon/bonaire_me.bin");
-MODULE_FIRMWARE("radeon/bonaire_ce.bin");
-MODULE_FIRMWARE("radeon/bonaire_rlc.bin");
-MODULE_FIRMWARE("radeon/bonaire_mec.bin");
-
-MODULE_FIRMWARE("radeon/hawaii_pfp.bin");
-MODULE_FIRMWARE("radeon/hawaii_me.bin");
-MODULE_FIRMWARE("radeon/hawaii_ce.bin");
-MODULE_FIRMWARE("radeon/hawaii_rlc.bin");
-MODULE_FIRMWARE("radeon/hawaii_mec.bin");
-
-MODULE_FIRMWARE("radeon/kaveri_pfp.bin");
-MODULE_FIRMWARE("radeon/kaveri_me.bin");
-MODULE_FIRMWARE("radeon/kaveri_ce.bin");
-MODULE_FIRMWARE("radeon/kaveri_rlc.bin");
-MODULE_FIRMWARE("radeon/kaveri_mec.bin");
-MODULE_FIRMWARE("radeon/kaveri_mec2.bin");
-
-MODULE_FIRMWARE("radeon/kabini_pfp.bin");
-MODULE_FIRMWARE("radeon/kabini_me.bin");
-MODULE_FIRMWARE("radeon/kabini_ce.bin");
-MODULE_FIRMWARE("radeon/kabini_rlc.bin");
-MODULE_FIRMWARE("radeon/kabini_mec.bin");
-
-MODULE_FIRMWARE("radeon/mullins_pfp.bin");
-MODULE_FIRMWARE("radeon/mullins_me.bin");
-MODULE_FIRMWARE("radeon/mullins_ce.bin");
-MODULE_FIRMWARE("radeon/mullins_rlc.bin");
-MODULE_FIRMWARE("radeon/mullins_mec.bin");
+MODULE_FIRMWARE("amdgpu/bonaire_pfp.bin");
+MODULE_FIRMWARE("amdgpu/bonaire_me.bin");
+MODULE_FIRMWARE("amdgpu/bonaire_ce.bin");
+MODULE_FIRMWARE("amdgpu/bonaire_rlc.bin");
+MODULE_FIRMWARE("amdgpu/bonaire_mec.bin");
+
+MODULE_FIRMWARE("amdgpu/hawaii_pfp.bin");
+MODULE_FIRMWARE("amdgpu/hawaii_me.bin");
+MODULE_FIRMWARE("amdgpu/hawaii_ce.bin");
+MODULE_FIRMWARE("amdgpu/hawaii_rlc.bin");
+MODULE_FIRMWARE("amdgpu/hawaii_mec.bin");
+
+MODULE_FIRMWARE("amdgpu/kaveri_pfp.bin");
+MODULE_FIRMWARE("amdgpu/kaveri_me.bin");
+MODULE_FIRMWARE("amdgpu/kaveri_ce.bin");
+MODULE_FIRMWARE("amdgpu/kaveri_rlc.bin");
+MODULE_FIRMWARE("amdgpu/kaveri_mec.bin");
+MODULE_FIRMWARE("amdgpu/kaveri_mec2.bin");
+
+MODULE_FIRMWARE("amdgpu/kabini_pfp.bin");
+MODULE_FIRMWARE("amdgpu/kabini_me.bin");
+MODULE_FIRMWARE("amdgpu/kabini_ce.bin");
+MODULE_FIRMWARE("amdgpu/kabini_rlc.bin");
+MODULE_FIRMWARE("amdgpu/kabini_mec.bin");
+
+MODULE_FIRMWARE("amdgpu/mullins_pfp.bin");
+MODULE_FIRMWARE("amdgpu/mullins_me.bin");
+MODULE_FIRMWARE("amdgpu/mullins_ce.bin");
+MODULE_FIRMWARE("amdgpu/mullins_rlc.bin");
+MODULE_FIRMWARE("amdgpu/mullins_mec.bin");
+
+MODULE_FIRMWARE("amdgpu/liverpool_pfp.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_me.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_ce.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_rlc.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec2.bin");
+
+MODULE_FIRMWARE("amdgpu/gladius_pfp.bin");
+MODULE_FIRMWARE("amdgpu/gladius_me.bin");
+MODULE_FIRMWARE("amdgpu/gladius_ce.bin");
+MODULE_FIRMWARE("amdgpu/gladius_rlc.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec2.bin");
 
 static const struct amdgpu_gds_reg_offset amdgpu_gds_reg_offset[] =
 {
@@ -878,6 +892,420 @@ static const u32 kalindi_rlc_save_restore_register_list[] =
 	(0x0e00 << 16) | (0x9600 >> 2),
 };
 
+static const u32 liverpool_rlc_save_restore_register_list[] =
+{
+	(0x0600 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x98f8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9900 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc260 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x90e8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c000 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c00c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c1c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8900 >> 2),
+	0x00000000,
+	0x3,
+	(0x0e00 << 16) | (0x9834 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bf0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bcc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8b24 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc704 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc708 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc768 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9100 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c010 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92a8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92ac >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c04 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c20 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c38 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c3c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xae00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9604 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac08 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac0c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac58 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac68 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac6c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac70 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac74 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac78 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac80 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac84 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac88 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac8c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x970c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9714 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9718 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x971c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88bc >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8980 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8988 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89a0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3e1fc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c210 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c214 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c218 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8904 >> 2),
+	0x00000000,
+	1,
+	(0x0e00 << 16) | (0x8c34 >> 2),
+};
 static u32 gfx_v7_0_get_csb_size(struct amdgpu_device *adev);
 static void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev, volatile u32 *buffer);
 static void gfx_v7_0_init_cp_pg_table(struct amdgpu_device *adev);
@@ -920,10 +1348,16 @@ static int gfx_v7_0_init_microcode(struct amdgpu_device *adev)
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_pfp.bin", chip_name);
+	snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_pfp.bin", chip_name);
 	err = request_firmware(&adev->gfx.pfp_fw, fw_name, adev->dev);
 	if (err)
 		goto out;
@@ -931,7 +1365,7 @@ static int gfx_v7_0_init_microcode(struct amdgpu_device *adev)
 	if (err)
 		goto out;
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_me.bin", chip_name);
+	snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_me.bin", chip_name);
 	err = request_firmware(&adev->gfx.me_fw, fw_name, adev->dev);
 	if (err)
 		goto out;
@@ -939,7 +1373,7 @@ static int gfx_v7_0_init_microcode(struct amdgpu_device *adev)
 	if (err)
 		goto out;
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_ce.bin", chip_name);
+	snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_ce.bin", chip_name);
 	err = request_firmware(&adev->gfx.ce_fw, fw_name, adev->dev);
 	if (err)
 		goto out;
@@ -947,7 +1381,7 @@ static int gfx_v7_0_init_microcode(struct amdgpu_device *adev)
 	if (err)
 		goto out;
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_mec.bin", chip_name);
+	snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_mec.bin", chip_name);
 	err = request_firmware(&adev->gfx.mec_fw, fw_name, adev->dev);
 	if (err)
 		goto out;
@@ -955,17 +1389,24 @@ static int gfx_v7_0_init_microcode(struct amdgpu_device *adev)
 	if (err)
 		goto out;
 
-	if (adev->asic_type == CHIP_KAVERI) {
-		snprintf(fw_name, sizeof(fw_name), "radeon/%s_mec2.bin", chip_name);
+	if (adev->asic_type == CHIP_KAVERI || adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_mec2.bin", chip_name);
 		err = request_firmware(&adev->gfx.mec2_fw, fw_name, adev->dev);
 		if (err)
+		{
+			pr_err("gfx7: Failed to open firmware \"%s\"\n", fw_name);
 			goto out;
+		}
 		err = amdgpu_ucode_validate(adev->gfx.mec2_fw);
 		if (err)
+		{
+			pr_err("gfx7: Failed to validate ucode firmware \"%s\"\n", fw_name);
 			goto out;
+		}
+
 	}
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_rlc.bin", chip_name);
+	snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_rlc.bin", chip_name);
 	err = request_firmware(&adev->gfx.rlc_fw, fw_name, adev->dev);
 	if (err)
 		goto out;
@@ -1215,6 +1656,151 @@ static void gfx_v7_0_tiling_mode_table_init(struct amdgpu_device *adev)
 			if (reg_offset != 7)
 				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
 		break;
+
+case CHIP_LIVERPOOL:
+case CHIP_GLADIUS:
+		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));
+		tile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));
+		tile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));
+		tile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(split_equal_to_row_size));
+		tile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));
+		tile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(split_equal_to_row_size));
+		tile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16));
+		tile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));
+		tile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));
+		tile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));
+		tile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+
+		macrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_2_BANK));
+		macrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_2_BANK));
+
+		for (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)
+			WREG32(mmGB_TILE_MODE0 + reg_offset, tile[reg_offset]);
+		for (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)
+			if (reg_offset != 7)
+				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
+		break;
 	case CHIP_HAWAII:
 		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
 			   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |
@@ -1657,6 +2243,16 @@ gfx_v7_0_raster_config(struct amdgpu_device *adev, u32 *rconf, u32 *rconf1)
 		*rconf |= 0x0;
 		*rconf1 |= 0x0;
 		break;
+	case CHIP_LIVERPOOL:
+		*rconf |= RB_MAP_PKR0(2) | RB_MAP_PKR1(2) |
+			  RB_XSEL2(1) | PKR_MAP(2) | PKR_XSEL(1) |
+			  PKR_YSEL(1) | SE_MAP(2) | SE_XSEL(2) |
+			  SE_YSEL(2);
+		*rconf1 |= 0x0;
+	case CHIP_GLADIUS:
+		*rconf |= 0x2a00161a;
+		*rconf1 |= 0x0000002e;
+		break;
 	default:
 		DRM_ERROR("unknown asic: 0x%x\n", adev->asic_type);
 		break;
@@ -2188,6 +2784,7 @@ static void gfx_v7_0_ring_emit_fence_gfx(struct amdgpu_ring *ring, u64 addr,
 				DATA_SEL(write64bit ? 2 : 1) | INT_SEL(int_sel ? 2 : 0));
 	amdgpu_ring_write(ring, lower_32_bits(seq));
 	amdgpu_ring_write(ring, upper_32_bits(seq));
+
 }
 
 /**
@@ -2337,7 +2934,6 @@ static int gfx_v7_0_ring_test_ib(struct amdgpu_ring *ring, long timeout)
 	r = amdgpu_ib_schedule(ring, 1, &ib, NULL, &f);
 	if (r)
 		goto err2;
-
 	r = dma_fence_wait_timeout(f, false, timeout);
 	if (r == 0) {
 		DRM_ERROR("amdgpu: IB test timed out\n");
@@ -2347,9 +2943,10 @@ static int gfx_v7_0_ring_test_ib(struct amdgpu_ring *ring, long timeout)
 		DRM_ERROR("amdgpu: fence wait failed (%ld).\n", r);
 		goto err2;
 	}
+
 	tmp = RREG32(scratch);
 	if (tmp == 0xDEADBEEF) {
-		DRM_INFO("ib test on ring %d succeeded\n", ring->idx);
+		DRM_INFO("ib test on ring %d succeeded in %d us\n", ring->idx, r);
 		r = 0;
 	} else {
 		DRM_ERROR("amdgpu: ib test failed (scratch(0x%04X)=0x%08X)\n",
@@ -2738,7 +3335,7 @@ static int gfx_v7_0_cp_compute_load_microcode(struct amdgpu_device *adev)
 		WREG32(mmCP_MEC_ME1_UCODE_DATA, le32_to_cpup(fw_data++));
 	WREG32(mmCP_MEC_ME1_UCODE_ADDR, 0);
 
-	if (adev->asic_type == CHIP_KAVERI) {
+	if (adev->asic_type == CHIP_KAVERI || adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS ) {
 		const struct gfx_firmware_header_v1_0 *mec2_hdr;
 
 		if (!adev->gfx.mec2_fw)
@@ -3318,6 +3915,14 @@ static int gfx_v7_0_rlc_init(struct amdgpu_device *adev)
 			adev->gfx.rlc.reg_list = spectre_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
 				(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_LIVERPOOL) {
+			adev->gfx.rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_GLADIUS) {
+			adev->gfx.rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
 		} else {
 			adev->gfx.rlc.reg_list = kalindi_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
@@ -3821,7 +4426,7 @@ static void gfx_v7_0_init_cp_pg_table(struct amdgpu_device *adev)
 	u32 bo_offset = 0;
 	u32 table_offset, table_size;
 
-	if (adev->asic_type == CHIP_KAVERI)
+	if (adev->asic_type == CHIP_KAVERI || adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
 		max_me = 5;
 
 	if (adev->gfx.rlc.cp_table_ptr == NULL)
@@ -3945,7 +4550,6 @@ static void gfx_v7_0_init_ao_cu_mask(struct amdgpu_device *adev)
 	u32 tmp;
 
 	WREG32(mmRLC_PG_ALWAYS_ON_CU_MASK, adev->gfx.cu_info.ao_cu_mask);
-
 	tmp = RREG32(mmRLC_MAX_PG_CU);
 	tmp &= ~RLC_MAX_PG_CU__MAX_POWERED_UP_CU_MASK;
 	tmp |= (adev->gfx.cu_info.number << RLC_MAX_PG_CU__MAX_POWERED_UP_CU__SHIFT);
@@ -4124,6 +4728,14 @@ static void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev,
 		buffer[count++] = cpu_to_le32(0x3a00161a);
 		buffer[count++] = cpu_to_le32(0x0000002e);
 		break;
+	case CHIP_LIVERPOOL:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x00000000);
+		break;
+	case CHIP_GLADIUS:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x0000002e);
+		break;
 	default:
 		buffer[count++] = cpu_to_le32(0x00000000);
 		buffer[count++] = cpu_to_le32(0x00000000);
@@ -4401,6 +5013,41 @@ static void gfx_v7_0_gpu_early_init(struct amdgpu_device *adev)
 		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
 		gb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;
 		break;
+	case CHIP_LIVERPOOL:
+		adev->gfx.config.max_shader_engines = 2; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 1; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 4; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;
+		break;
+
+	case CHIP_GLADIUS:
+		adev->gfx.config.max_shader_engines = 4; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 2; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 8; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = 0x10000000; //0x22011003; //0x12011003;
+		break;
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
 	default:
@@ -4521,6 +5168,8 @@ static int gfx_v7_0_sw_init(void *handle)
 
 	switch (adev->asic_type) {
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		adev->gfx.mec.num_mec = 2;
 		break;
 	case CHIP_BONAIRE:
@@ -4856,7 +5505,6 @@ static void gfx_v7_0_set_compute_eop_interrupt_state(struct amdgpu_device *adev,
 		DRM_DEBUG("invalid me %d\n", me);
 		return;
 	}
-
 	switch (state) {
 	case AMDGPU_IRQ_STATE_DISABLE:
 		mec_int_cntl = RREG32(mec_int_cntl_reg);
@@ -4970,7 +5618,6 @@ static int gfx_v7_0_eop_irq(struct amdgpu_device *adev,
 	struct amdgpu_ring *ring;
 	int i;
 
-	DRM_DEBUG("IH: CP EOP\n");
 	me_id = (entry->ring_id & 0x0c) >> 2;
 	pipe_id = (entry->ring_id & 0x03) >> 0;
 	switch (me_id) {
@@ -5212,6 +5859,9 @@ static void gfx_v7_0_get_cu_info(struct amdgpu_device *adev)
 	else
 		ao_cu_num = adev->gfx.config.max_cu_per_sh;
 
+	if(adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+		ao_cu_num = adev->gfx.config.max_cu_per_sh;
+
 	memset(cu_info, 0, sizeof(*cu_info));
 
 	amdgpu_gfx_parse_disable_cu(disable_masks, 4, 2);
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
index eace9e7182c8a8..0c7318526c60b4 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
@@ -142,6 +142,8 @@ static int gmc_v7_0_init_microcode(struct amdgpu_device *adev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return 0;
 	default: BUG();
 	}
@@ -394,6 +396,10 @@ static int gmc_v7_0_mc_init(struct amdgpu_device *adev)
 			adev->mc.gart_size = 256ULL << 20;
 			break;
 #ifdef CONFIG_DRM_AMDGPU_CIK
+		case CHIP_LIVERPOOL:
+		case CHIP_GLADIUS:
+			adev->mc.gart_size = 512ULL << 20;
+			break;
 		case CHIP_BONAIRE: /* UVD, VCE do not support GPUVM */
 		case CHIP_HAWAII:  /* UVD, VCE do not support GPUVM */
 		case CHIP_KAVERI:  /* UVD, VCE do not support GPUVM */
@@ -651,7 +657,18 @@ static int gmc_v7_0_gart_enable(struct amdgpu_device *adev)
 			WREG32(mmVM_CONTEXT8_PAGE_TABLE_BASE_ADDR + i - 8,
 			       adev->gart.table_addr >> 12);
 	}
-
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		for (i = 2; i < 8; i++) {
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+		for (i = 0; i < 8; i++) {
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+	}
 	/* enable context1-15 */
 	WREG32(mmVM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,
 	       (u32)(adev->dummy_page.addr >> 12));
diff --git a/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c b/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c
new file mode 100644
index 00000000000000..61dfcc677464c4
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c
@@ -0,0 +1,758 @@
+/*
+ * Panasonic MN86471A DP->HDMI bridge driver (via PS4 Aeolia ICC interface)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/ps4.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drmP.h>
+
+#include "amdgpu_mode.h"
+#include "atombios_dp.h"
+#include "ObjectID.h"
+
+#define CMD_READ	1, 1
+#define CMD_WRITE	2, 2
+#define CMD_MASK	2, 3
+#define CMD_DELAY	3, 1
+#define CMD_WAIT_SET	3, 2
+#define CMD_WAIT_CLEAR	3, 3
+
+#define TSYSCTRL 0x7005
+# define TSYSCTRL_HDMI BIT(7)
+
+#define TSRST 0x7006
+# define TSRST_AVCSRST BIT(0)
+# define TSRST_ENCSRST BIT(1)
+# define TSRST_FIFOSRST BIT(2)
+# define TSRST_CCSRST BIT(3)
+# define TSRST_HDCPSRST BIT(4)
+# define TSRST_AUDSRST BIT(6)
+# define TSRST_VIFSRST BIT(7)
+
+#define TMONREG 0x7008
+# define TMONREG_HPD BIT(3)
+
+#define TDPCMODE 0x7009
+
+
+#define UPDCTRL 0x7011
+# define UPDCTRL_ALLUPD BIT(7)
+# define UPDCTRL_AVIIUPD BIT(6)
+# define UPDCTRL_AUDIUPD BIT(5)
+# define UPDCTRL_CLKUPD BIT(4)
+# define UPDCTRL_HVSIUPD BIT(3)
+# define UPDCTRL_VIFUPD BIT(2)
+# define UPDCTRL_AUDUPD BIT(1)
+# define UPDCTRL_CSCUPD BIT(0)
+
+
+#define VINCNT 0x7040
+# define VINCNT_VIF_FILEN BIT(6)
+
+#define VMUTECNT 0x705f
+# define VMUTECNT_CCVMUTE BIT(7)
+# define VMUTECNT_DUMON BIT(6)
+# define VMUTECNT_LINEWIDTH_80 (0<<4)
+# define VMUTECNT_LINEWIDTH_90 (1<<4)
+# define VMUTECNT_LINEWIDTH_180 (2<<4)
+# define VMUTECNT_LINEWIDTH_360 (3<<4)
+# define VMUTECNT_VMUTE_MUTE_ASYNC 1
+# define VMUTECNT_VMUTE_MUTE_NORMAL 2
+# define VMUTECNT_VMUTE_MUTE_RAMPA 4
+# define VMUTECNT_VMUTE_MUTE_RAMPB 8
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_RGB 10
+# define VMUTECNT_VMUTE_MUTE_TOGGLE 12
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_YCBCR 14
+
+#define CSCMOD 0x70c0
+#define C420SET 0x70c2
+#define OUTWSET 0x70c3
+
+#define PKTENA 0x7202
+
+#define INFENA 0x7203
+# define INFENA_AVIEN BIT(6)
+
+#define AKESTA 0x7a84
+# define AKESTA_BUSY BIT(0)
+
+#define AKESRST 0x7a88
+
+#define HDCPEN 0x7a8b
+# define HDCPEN_NONE 0x00
+# define HDCPEN_ENC_EN 0x03
+# define HDCPEN_ENC_DIS 0x05
+
+#define PCI_DEVICE_ID_CUH_11XX 0x9920
+#define PCI_DEVICE_ID_CUH_12XX 0x9922
+#define PCI_DEVICE_ID_CUH_2XXX 0x9923
+#define PCI_DEVICE_ID_CUH_7XXX 0x9924
+
+struct i2c_cmd_hdr {
+	u8 major;
+	u8 length;
+	u8 minor;
+	u8 count;
+} __packed;
+
+struct i2c_cmdqueue {
+	struct {
+		u8 code;
+		u16 length;
+		u8 count;
+		u8 cmdbuf[0x7ec];
+	} __packed req;
+	struct {
+		u8 res1, res2;
+		u8 unk1, unk2;
+		u8 count;
+		u8 databuf[0x7eb];
+	} __packed reply;
+
+	u8 *p;
+	struct i2c_cmd_hdr *cmd;
+};
+
+struct ps4_bridge {
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_bridge bridge;
+	struct i2c_cmdqueue cq;
+	struct mutex mutex;
+
+	int mode;
+};
+
+/* this should really be taken care of by the connector, but that is currently
+ * contained/owned by radeon_connector so just use a global for now */
+static struct ps4_bridge g_bridge = {
+	.mutex = __MUTEX_INITIALIZER(g_bridge.mutex)
+};
+
+static void cq_init(struct i2c_cmdqueue *q, u8 code)
+{
+	q->req.code = code;
+	q->req.count = 0;
+	q->p = q->req.cmdbuf;
+	q->cmd = NULL;
+}
+
+static void cq_cmd(struct i2c_cmdqueue *q, u8 major, u8 minor)
+{
+	if (!q->cmd || q->cmd->major != major || q->cmd->minor != minor) {
+		if (q->cmd)
+			q->cmd->length = q->p - (u8 *)q->cmd;
+		q->cmd = (struct i2c_cmd_hdr *)q->p;
+		q->cmd->major = major;
+		q->cmd->minor = minor;
+		q->cmd->length = 0;
+		q->cmd->count = 1;
+		q->req.count += 1;
+		q->p += sizeof(*q->cmd);
+	} else {
+		q->cmd->count += 1;
+	}
+}
+
+static int cq_exec(struct i2c_cmdqueue *q)
+{
+	int res;
+
+	if (!q->cmd)
+		return 0;
+
+	q->cmd->length = q->p - (u8 *)q->cmd;
+	q->req.length = q->p - (u8 *)&q->req;
+
+	res = apcie_icc_cmd(0x10, 0, &q->req, q->req.length,
+		      &q->reply, sizeof(q->reply));
+
+	if (res < 5) {
+		DRM_ERROR("icc i2c commandqueue failed: %d\n", res);
+		return -EIO;
+	}
+	if (q->reply.res1 != 0 || q->reply.res2) {
+		DRM_ERROR("icc i2c commandqueue failed: %d, %d\n",
+			  q->reply.res1, q->reply.res2);
+		return -EIO;
+	}
+
+	return res;
+}
+
+static void cq_read(struct i2c_cmdqueue *q, u16 addr, u8 count)
+{
+	cq_cmd(q, CMD_READ);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = 0;
+}
+
+static void cq_writereg(struct i2c_cmdqueue *q, u16 addr, u8 data)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = data;
+}
+
+#if 0
+static void cq_write(struct i2c_cmdqueue *q, u16 addr, u8 *data, u8 count)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	while (count--)
+		*q->p++ = *data++;
+}
+#endif
+
+static void cq_mask(struct i2c_cmdqueue *q, u16 addr, u8 value, u8 mask)
+{
+	cq_cmd(q, CMD_MASK);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = value;
+	*q->p++ = mask;
+}
+
+#if 1
+static void cq_delay(struct i2c_cmdqueue *q, u16 time)
+{
+	cq_cmd(q, CMD_DELAY);
+	*q->p++ = 0;
+	*q->p++ = time & 0xff;
+	*q->p++ = time>>8;
+	*q->p++ = 0;
+}
+#endif
+
+static void cq_wait_set(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_SET);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static void cq_wait_clear(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_CLEAR);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static inline struct ps4_bridge *
+		bridge_to_ps4_bridge(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct ps4_bridge, bridge);
+}
+
+static void ps4_bridge_mode_set(struct drm_bridge *bridge,
+			      struct drm_display_mode *mode,
+			      struct drm_display_mode *adjusted_mode)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+
+	/* This gets called before pre_enable/enable, so we just stash
+	 * the vic ID for later */
+	mn_bridge->mode = drm_match_cea_mode(adjusted_mode);
+	DRM_DEBUG_KMS("vic mode: %d\n", mn_bridge->mode);
+	if (!mn_bridge->mode) {
+		DRM_ERROR("attempted to set non-CEA mode\n");
+	}
+}
+
+static void ps4_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_pre_enable\n");
+	DRM_DEBUG("Enable ps4_bridge_pre_enable\n");
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+
+#if 0
+	/* No idea. DP stuff probably. This borks for some reason. Meh. */
+	cq_writereg(&mn_bridge->cq, 0x7657,0xff);
+	cq_writereg(&mn_bridge->cq, 0x76a5,0x80);
+	cq_writereg(&mn_bridge->cq, 0x76a6,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7601,0x0a);
+	cq_writereg(&mn_bridge->cq, 0x7602,0x84);
+	cq_writereg(&mn_bridge->cq, 0x7603,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76a8,0x09);
+	cq_writereg(&mn_bridge->cq, 0x76ae,0xd1);
+	cq_writereg(&mn_bridge->cq, 0x76af,0x50);
+	cq_writereg(&mn_bridge->cq, 0x76b0,0x70);
+	cq_writereg(&mn_bridge->cq, 0x76b1,0xb0);
+	cq_writereg(&mn_bridge->cq, 0x76b2,0xf0);
+	cq_writereg(&mn_bridge->cq, 0x76db,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76dc,0x64);
+	cq_writereg(&mn_bridge->cq, 0x76dd,0x22);
+	cq_writereg(&mn_bridge->cq, 0x76e4,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76e6,0x1e); /* 0 for (DP?) scramble off */
+	cq_writereg(&mn_bridge->cq, 0x7670,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7671,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7672,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7673,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7668,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7669,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766a,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766b,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7655,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7007,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7098,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7099,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709a,0x0f);
+	cq_writereg(&mn_bridge->cq, 0x709b,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709c,0x50);
+	cq_writereg(&mn_bridge->cq, 0x709d,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709e,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709f,0xd0);
+	cq_writereg(&mn_bridge->cq, 0x7a9c,0x2e);
+	cq_writereg(&mn_bridge->cq, 0x7021,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7028,0x00);
+	cq_writereg(&mn_bridge->cq, 0x7030,0xa3);
+	cq_writereg(&mn_bridge->cq, 0x7016,0x04);
+#endif
+
+	/* Disable InfoFrames */
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	/* Reset HDCP */
+	cq_writereg(&mn_bridge->cq, TSRST, TSRST_ENCSRST | TSRST_HDCPSRST);
+	/* Disable HDCP flag */
+	cq_writereg(&mn_bridge->cq, TSRST, HDCPEN_ENC_DIS);
+	/* HDCP AKE reset */
+	cq_writereg(&mn_bridge->cq, AKESRST, 0xff);
+	/* Wait AKE busy */
+	cq_wait_clear(&mn_bridge->cq, AKESTA, AKESTA_BUSY);
+
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("failed to run pre-enable sequence");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	struct drm_connector *connector = mn_bridge->connector;
+	struct drm_device *dev = connector->dev;
+	struct pci_dev *pdev = dev->pdev;
+	u8 dp[3];
+	DRM_DEBUG("Enable PS4_BRIDGE_ENABLE\n");
+	if (!mn_bridge->mode) {
+		DRM_ERROR("mode not available\n");
+		return;
+	}
+
+	if(pdev->vendor != PCI_VENDOR_ID_ATI) {
+		DRM_ERROR("Invalid vendor: %04x", pdev->vendor);
+		return;
+	}
+
+	DRM_DEBUG_KMS("ps4_bridge_enable (mode: %d)\n", mn_bridge->mode);
+
+	/* Here come the dragons */
+
+	if(pdev->device == PCI_DEVICE_ID_CUH_11XX)
+	{
+		/* Panasonic MN86471A */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Read DisplayPort status (?) */
+		cq_read(&mn_bridge->cq, 0x76e1, 3);
+		if (cq_exec(&mn_bridge->cq) < 11) {
+			mutex_unlock(&mn_bridge->mutex);
+			DRM_ERROR("could not read DP status");
+		return;
+		}
+		memcpy(dp, &mn_bridge->cq.reply.databuf[3], 3);
+
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x761e, 0x77);
+		cq_wait_set(&mn_bridge->cq, 0x761f, 0x77);
+		/* Wait for ?? */
+		cq_wait_set(&mn_bridge->cq, 0x7669, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x76d9, (dp[0] & 0x1f) | (dp[0] << 5));
+		cq_writereg(&mn_bridge->cq, 0x76da, (dp[1] & 0x7c) | ((dp[0] >> 3) & 3) | ((dp[1] << 5) & 0x80));
+		cq_writereg(&mn_bridge->cq, 0x76db, 0x80 | ((dp[1] >> 3) & 0xf));
+		cq_writereg(&mn_bridge->cq, 0x76e4, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, VINCNT, VINCNT_VIF_FILEN);
+		cq_writereg(&mn_bridge->cq, 0x7071, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x765a, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7215, 0x28); /* aspect */
+		cq_writereg(&mn_bridge->cq, 0x7217, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0);
+		cq_writereg(&mn_bridge->cq, CSCMOD, 0xdc);
+		cq_writereg(&mn_bridge->cq, C420SET, 0xaa);
+		cq_writereg(&mn_bridge->cq, TDPCMODE, 0x4a);
+		cq_writereg(&mn_bridge->cq, OUTWSET, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7027, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x700b, 0x01);
+		cq_writereg(&mn_bridge->cq, PKTENA, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, INFENA, INFENA_AVIEN);
+		cq_writereg(&mn_bridge->cq, UPDCTRL, UPDCTRL_ALLUPD | UPDCTRL_AVIIUPD |
+						     UPDCTRL_CLKUPD | UPDCTRL_VIFUPD |
+						     UPDCTRL_CSCUPD);
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_mask(&mn_bridge->cq, 0x7216, 0x00, 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0x00);
+
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+		cq_writereg(&mn_bridge->cq, 0x7016, 0x04);
+		cq_writereg(&mn_bridge->cq, 0x7a88, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7a83, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_writereg(&mn_bridge->cq, 0x7006, 0x02);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN86471A) mode\n");
+		}
+		#if 1
+		// preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b3, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70b7, 0x0b);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0x24);
+
+		cq_mask(&mn_bridge->cq,0x70b9, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x40, 0x70);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x20, 0xe0);
+		cq_mask(&mn_bridge->cq,0x7257, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x00, 0x88);
+		cq_mask(&mn_bridge->cq,0x70b9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable MN86471A hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x7ed8, 0x01);
+
+		cq_mask(&mn_bridge->cq,0x70b4, 0x00, 0x3e);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x3f);
+		cq_mask(&mn_bridge->cq,0x70b7, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70bd, 0x00, 0xff);
+
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+
+		cq_wait_set(&mn_bridge->cq,0x7096, 0x80);
+		cq_writereg(&mn_bridge->cq,0x7096, 0xff);
+
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70b1, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable hdmi MN86471A audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+	else
+	{
+		/* Panasonic MN864729 */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+		cq_mask(&mn_bridge->cq, 0x6005, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a03, 0x47);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x60f8, 0xff);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a01, 0x4d);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x1a);
+
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x00, 0x21);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x00, 0x70);
+		// 03 08 01 01 00  2c 01 00
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x00);
+		cq_delay(&mn_bridge->cq, 0x0032);
+		cq_writereg(&mn_bridge->cq, 0x7402, 0x1c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x04);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, 0x10c7, 0x38);
+		cq_writereg(&mn_bridge->cq, 0x1e02, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x1e00, 0x66);
+		cq_writereg(&mn_bridge->cq, 0x100c, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+
+		cq_writereg(&mn_bridge->cq, 0x7009, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7040, 0x42);
+		cq_writereg(&mn_bridge->cq, 0x7225, 0x28);
+		cq_writereg(&mn_bridge->cq, 0x7227, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7228, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7070, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7071, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7072, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7073, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7074, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7075, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c2, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70fe, 0x12);
+		cq_writereg(&mn_bridge->cq, 0x70c3, 0x10);
+
+		if(pdev->device == PCI_DEVICE_ID_CUH_12XX) {
+			/* newer ps4 phats need here 0x03 idk why. */
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x03);
+		} else {
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x00);
+		}
+
+		cq_writereg(&mn_bridge->cq, 0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7202, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7203, 0x60);
+		cq_writereg(&mn_bridge->cq, 0x7011, 0xd5);
+		//cq_writereg(&mn_bridge->cq, 0x7a00, 0x0e);
+
+		cq_wait_set(&mn_bridge->cq, 0x10f6, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7226, 0x00, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7228, 0x00, 0xFF);
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+		cq_wait_clear(&mn_bridge->cq, 0x7204, 0x40);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x05);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x70, 0x70);
+		cq_mask(&mn_bridge->cq, 0x1034, 0x02, 0x02);
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		cq_writereg(&mn_bridge->cq, HDCPEN, 0x00);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN864729) mode\n");
+		}
+		#if 1
+		// AUDIO preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70aa, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70af, 0x07);
+		cq_writereg(&mn_bridge->cq,0x70a9, 0x5a);
+
+		cq_mask(&mn_bridge->cq,0x70af, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70af, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x80, 0xe0);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x01, 0x07);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x80, 0x88);
+		cq_mask(&mn_bridge->cq,0x70a9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b0, 0x01);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b1, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b4, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+		cq_wait_set(&mn_bridge->cq,0x10f6, 0xa2);
+		cq_mask(&mn_bridge->cq,0x7267, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7204, 0x10);
+		cq_wait_clear(&mn_bridge->cq,0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+
+}
+
+static void ps4_bridge_disable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_disable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("Failed to disable bridge\n");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_post_disable(struct drm_bridge *bridge)
+{
+	/* struct ps4_bridge *mn_bridge = bridge_to_mn864729(bridge); */
+	DRM_DEBUG_KMS("ps4_bridge_post_disable\n");
+}
+
+/* Hardcoded modes, since we don't really know how to do custom modes yet.
+ * Other CEA modes *should* work (and are allowed if externally added) */
+
+/* 1 - 640x480@60Hz */
+static const struct drm_display_mode mode_480p = {
+	DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		 752, 800, 0, 480, 490, 492, 525, 0,
+		 DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3
+};
+/* 4 - 1280x720@60Hz */
+static const struct drm_display_mode mode_720p = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		 1430, 1650, 0, 720, 725, 730, 750, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+/* 16 - 1920x1080@60Hz */
+static const struct drm_display_mode mode_1080p = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		 2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+
+int ps4_bridge_get_modes(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_display_mode *newmode;
+	DRM_DEBUG_KMS("ps4_bridge_get_modes\n");
+
+	newmode = drm_mode_duplicate(dev, &mode_1080p);
+	drm_mode_probed_add(connector, newmode);
+
+	//newmode = drm_mode_duplicate(dev, &mode_720p);
+	//drm_mode_probed_add(connector, newmode);
+	//newmode = drm_mode_duplicate(dev, &mode_480p);
+	//drm_mode_probed_add(connector, newmode);
+
+	drm_mode_connector_update_edid_property(connector, NULL);
+
+	return 0;
+}
+
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+		bool force)
+{
+	struct ps4_bridge *mn_bridge = &g_bridge;
+	u8 reg;
+
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;
+
+	amdgpu_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;
+	amdgpu_atombios_dp_get_dpcd(amdgpu_connector);
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_read(&mn_bridge->cq, TMONREG, 1);
+	if (cq_exec(&mn_bridge->cq) < 9) {
+		mutex_unlock(&mn_bridge->mutex);
+		DRM_ERROR("could not read TMONREG");
+		return connector_status_disconnected;
+	}
+	reg = mn_bridge->cq.reply.databuf[3];
+	mutex_unlock(&mn_bridge->mutex);
+
+	DRM_DEBUG_KMS("TMONREG=0x%02x\n", reg);
+
+	if (reg & TMONREG_HPD)
+		return connector_status_connected;
+	else
+		return connector_status_disconnected;
+}
+
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+				  struct drm_display_mode *mode)
+{
+	int vic = drm_match_cea_mode(mode);
+
+	/* Allow anything that we can match up to a VIC (CEA modes) */
+	if (!vic || (vic != 16 && vic != 4)) {
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static int ps4_bridge_attach(struct drm_bridge *bridge)
+{
+	/* struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge); */
+
+	return 0;
+}
+
+static struct drm_bridge_funcs ps4_bridge_funcs = {
+	.pre_enable = ps4_bridge_pre_enable,
+	.enable = ps4_bridge_enable,
+	.disable = ps4_bridge_disable,
+	.post_disable = ps4_bridge_post_disable,
+	.attach = ps4_bridge_attach,
+	.mode_set = ps4_bridge_mode_set
+};
+
+int ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder)
+{
+	int ret;
+	struct ps4_bridge *mn_bridge = &g_bridge;
+
+	mn_bridge->encoder = encoder;
+	mn_bridge->connector = connector;
+	mn_bridge->bridge.funcs = &ps4_bridge_funcs;
+	ret = drm_bridge_attach(mn_bridge->encoder, &mn_bridge->bridge, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize bridge with drm\n");
+		return -EINVAL;
+	}
+
+	encoder->bridge = &mn_bridge->bridge;
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/amd/include/amd_shared.h b/drivers/gpu/drm/amd/include/amd_shared.h
index 70e8c20acb2fd5..157c0b20696eda 100644
--- a/drivers/gpu/drm/amd/include/amd_shared.h
+++ b/drivers/gpu/drm/amd/include/amd_shared.h
@@ -24,7 +24,6 @@
 #define __AMD_SHARED_H__
 
 #define AMD_MAX_USEC_TIMEOUT		200000  /* 200 ms */
-
 /*
  * Supported ASIC types
  */
@@ -37,6 +36,8 @@ enum amd_asic_type {
 	CHIP_BONAIRE,
 	CHIP_KAVERI,
 	CHIP_KABINI,
+	CHIP_LIVERPOOL,
+	CHIP_GLADIUS,
 	CHIP_HAWAII,
 	CHIP_MULLINS,
 	CHIP_TOPAZ,
diff --git a/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h b/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
index 9da033dc1a346e..3ac8b09a185259 100644
--- a/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
+++ b/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
@@ -589,8 +589,24 @@
 #define mmVM_CONTEXT13_PAGE_TABLE_BASE_ADDR                                     0x513
 #define mmVM_CONTEXT14_PAGE_TABLE_BASE_ADDR                                     0x514
 #define mmVM_CONTEXT15_PAGE_TABLE_BASE_ADDR                                     0x515
+#define mmVM_CONTEXT8_PAGE_TABLE_START_ADDR                                     0x516
+#define mmVM_CONTEXT9_PAGE_TABLE_START_ADDR                                     0x517
+#define mmVM_CONTEXT10_PAGE_TABLE_START_ADDR                                    0x518
+#define mmVM_CONTEXT11_PAGE_TABLE_START_ADDR                                    0x519
+#define mmVM_CONTEXT12_PAGE_TABLE_START_ADDR                                    0x51a
+#define mmVM_CONTEXT13_PAGE_TABLE_START_ADDR                                    0x51b
+#define mmVM_CONTEXT14_PAGE_TABLE_START_ADDR                                    0x51c
+#define mmVM_CONTEXT15_PAGE_TABLE_START_ADDR                                    0x51d
 #define mmVM_INVALIDATE_REQUEST                                                 0x51e
 #define mmVM_INVALIDATE_RESPONSE                                                0x51f
+#define mmVM_CONTEXT8_PAGE_TABLE_END_ADDR                                       0x524
+#define mmVM_CONTEXT9_PAGE_TABLE_END_ADDR                                       0x525
+#define mmVM_CONTEXT10_PAGE_TABLE_END_ADDR                                      0x526
+#define mmVM_CONTEXT11_PAGE_TABLE_END_ADDR                                      0x527
+#define mmVM_CONTEXT12_PAGE_TABLE_END_ADDR                                      0x528
+#define mmVM_CONTEXT13_PAGE_TABLE_END_ADDR                                      0x529
+#define mmVM_CONTEXT14_PAGE_TABLE_END_ADDR                                      0x52a
+#define mmVM_CONTEXT15_PAGE_TABLE_END_ADDR                                      0x52b
 #define mmVM_PRT_APERTURE0_LOW_ADDR                                             0x52c
 #define mmVM_PRT_APERTURE1_LOW_ADDR                                             0x52d
 #define mmVM_PRT_APERTURE2_LOW_ADDR                                             0x52e
@@ -620,8 +636,20 @@
 #define mmVM_CONTEXT7_PAGE_TABLE_BASE_ADDR                                      0x556
 #define mmVM_CONTEXT0_PAGE_TABLE_START_ADDR                                     0x557
 #define mmVM_CONTEXT1_PAGE_TABLE_START_ADDR                                     0x558
+#define mmVM_CONTEXT2_PAGE_TABLE_START_ADDR                                     0x559
+#define mmVM_CONTEXT3_PAGE_TABLE_START_ADDR                                     0x55a
+#define mmVM_CONTEXT4_PAGE_TABLE_START_ADDR                                     0x55b
+#define mmVM_CONTEXT5_PAGE_TABLE_START_ADDR                                     0x55c
+#define mmVM_CONTEXT6_PAGE_TABLE_START_ADDR                                     0x55d
+#define mmVM_CONTEXT7_PAGE_TABLE_START_ADDR                                     0x55e
 #define mmVM_CONTEXT0_PAGE_TABLE_END_ADDR                                       0x55f
 #define mmVM_CONTEXT1_PAGE_TABLE_END_ADDR                                       0x560
+#define mmVM_CONTEXT2_PAGE_TABLE_END_ADDR                                       0x561
+#define mmVM_CONTEXT3_PAGE_TABLE_END_ADDR                                       0x562
+#define mmVM_CONTEXT4_PAGE_TABLE_END_ADDR                                       0x563
+#define mmVM_CONTEXT5_PAGE_TABLE_END_ADDR                                       0x564
+#define mmVM_CONTEXT6_PAGE_TABLE_END_ADDR                                       0x565
+#define mmVM_CONTEXT7_PAGE_TABLE_END_ADDR                                       0x566
 #define mmVM_DEBUG                                                              0x56f
 #define mmVM_L2_CG                                                              0x570
 #define mmVM_L2_BANK_SELECT_MASKA                                               0x572
diff --git a/drivers/gpu/drm/drm_pci.c b/drivers/gpu/drm/drm_pci.c
index 1235c9877d6f1c..1e7335f8c93088 100644
--- a/drivers/gpu/drm/drm_pci.c
+++ b/drivers/gpu/drm/drm_pci.c
@@ -332,7 +332,7 @@ int drm_pcie_get_speed_cap_mask(struct drm_device *dev, u32 *mask)
 	u32 lnkcap, lnkcap2;
 
 	*mask = 0;
-	if (!dev->pdev)
+	if (!dev->pdev || pci_is_root_bus(dev->pdev->bus))
 		return -EINVAL;
 
 	root = dev->pdev->bus->self;
diff --git a/drivers/gpu/drm/radeon/Makefile b/drivers/gpu/drm/radeon/Makefile
index 0ad8244b5ccf4a..ce0985bb3eb850 100644
--- a/drivers/gpu/drm/radeon/Makefile
+++ b/drivers/gpu/drm/radeon/Makefile
@@ -82,6 +82,8 @@ radeon-y += radeon_device.o radeon_asic.o radeon_kms.o \
 
 radeon-$(CONFIG_MMU_NOTIFIER) += radeon_mn.o
 
+radeon-$(CONFIG_X86_PS4) += ps4_bridge.o
+
 # add async DMA block
 radeon-y += \
 	r600_dma.o \
diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c
index e67ed383e11b12..f1d1cfbb1a703d 100644
--- a/drivers/gpu/drm/radeon/atombios_encoders.c
+++ b/drivers/gpu/drm/radeon/atombios_encoders.c
@@ -689,7 +689,7 @@ atombios_get_encoder_mode(struct drm_encoder *encoder)
 	if (radeon_encoder->is_mst_encoder || radeon_encoder->offset)
 		return ATOM_ENCODER_MODE_DP_MST;
 	/* dp bridges are always DP */
-	if (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)
+	if (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE || rdev->family == CHIP_LIVERPOOL)
 		return ATOM_ENCODER_MODE_DP;
 
 	/* DVO is always DVO */
diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c
index ce8b353b5753ab..58504e47da2ae6 100644
--- a/drivers/gpu/drm/radeon/cik.c
+++ b/drivers/gpu/drm/radeon/cik.c
@@ -121,6 +121,13 @@ MODULE_FIRMWARE("radeon/mullins_mec.bin");
 MODULE_FIRMWARE("radeon/mullins_rlc.bin");
 MODULE_FIRMWARE("radeon/mullins_sdma.bin");
 
+MODULE_FIRMWARE("radeon/LIVERPOOL_pfp.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_me.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_ce.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_mec.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_rlc.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_sdma.bin");
+
 extern int r600_ih_ring_alloc(struct radeon_device *rdev);
 extern void r600_ih_ring_fini(struct radeon_device *rdev);
 extern void evergreen_mc_stop(struct radeon_device *rdev, struct evergreen_mc_save *save);
@@ -1041,6 +1048,421 @@ static const u32 kalindi_rlc_save_restore_register_list[] =
 	(0x0e00 << 16) | (0x9600 >> 2),
 };
 
+static const u32 liverpool_rlc_save_restore_register_list[] =
+{
+	(0x0600 << 16) | 0x263d,
+	0x00000000,
+	(0x0680 << 16) | 0x263d,
+	0x00000000,
+	(0x0e00 << 16) | 0x263e,
+	0x00000000,
+	(0x0e00 << 16) | 0x2640,
+	0x00000000,
+	(0x0e00 << 16) | 0x3098,
+	0x00000000,
+	(0x0e00 << 16) | 0x243a,
+	0x00000000,
+	(0x0e00 << 16) | 0xf000,
+	0x00000000,
+	(0x0e00 << 16) | 0xf003,
+	0x00000000,
+	(0x0e00 << 16) | 0x2307,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c0,
+	0x00000000,
+	(0x0e00 << 16) | 0x3348,
+	0x00000000,
+	(0x1e00 << 16) | 0x3348,
+	0x00000000,
+	(0x4e00 << 16) | 0x3348,
+	0x00000000,
+	(0x5e00 << 16) | 0x3348,
+	0x00000000,
+	(0x6e00 << 16) | 0x3348,
+	0x00000000,
+	(0x7e00 << 16) | 0x3348,
+	0x00000000,
+	(0x8e00 << 16) | 0x3348,
+	0x00000000,
+	(0x9e00 << 16) | 0x3348,
+	0x00000000,
+	(0xae00 << 16) | 0x3348,
+	0x00000000,
+	(0xbe00 << 16) | 0x3348,
+	0x00000000,
+	(0x0400 << 16) | 0x226f,
+	0x00000000,
+	(0x0480 << 16) | 0x226f,
+	0x00000000,
+	(0x0e00 << 16) | 0x2240,
+	0x00000000,
+	0x3,
+	(0x0e00 << 16) | 0x260d,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0600 << 16) | 0x26df,
+	0x00000000,
+	(0x0680 << 16) | 0x26df,
+	0x00000000,
+	(0x0e00 << 16) | 0x2285,
+	0x00000000,
+	(0x0e00 << 16) | 0x2286,
+	0x00000000,
+	(0x0600 << 16) | 0xc280,
+	0x00000000,
+	(0x0680 << 16) | 0xc280,
+	0x00000000,
+	(0x1600 << 16) | 0xc280,
+	0x00000000,
+	(0x1680 << 16) | 0xc280,
+	0x00000000,
+	(0x0e00 << 16) | 0x22fc,
+	0x00000000,
+	(0x0e00 << 16) | 0x22f3,
+	0x00000000,
+	(0x0e00 << 16) | 0x22c9,
+	0x00000000,
+	(0x0e00 << 16) | 0xc281,
+	0x00000000,
+	(0x1e00 << 16) | 0xc281,
+	0x00000000,
+	(0x0600 << 16) | 0xc284,
+	0x00000000,
+	(0x0680 << 16) | 0xc284,
+	0x00000000,
+	(0x1600 << 16) | 0xc284,
+	0x00000000,
+	(0x1680 << 16) | 0xc284,
+	0x00000000,
+	(0x0600 << 16) | 0xc285,
+	0x00000000,
+	(0x0680 << 16) | 0xc285,
+	0x00000000,
+	(0x1600 << 16) | 0xc285,
+	0x00000000,
+	(0x1680 << 16) | 0xc285,
+	0x00000000,
+	(0x0600 << 16) | 0xc286,
+	0x00000000,
+	(0x0680 << 16) | 0xc286,
+	0x00000000,
+	(0x1600 << 16) | 0xc286,
+	0x00000000,
+	(0x1680 << 16) | 0xc286,
+	0x00000000,
+	(0x0600 << 16) | 0xc28b,
+	0x00000000,
+	(0x0680 << 16) | 0xc28b,
+	0x00000000,
+	(0x1600 << 16) | 0xc28b,
+	0x00000000,
+	(0x1680 << 16) | 0xc28b,
+	0x00000000,
+	(0x0e00 << 16) | 0x31c0,
+	0x00000000,
+	(0x0e00 << 16) | 0x31c1,
+	0x00000000,
+	(0x0e00 << 16) | 0x31c2,
+	0x00000000,
+	(0x0e00 << 16) | 0x31da,
+	0x00000000,
+	(0x0400 << 16) | 0x31dc,
+	0x00000000,
+	(0x0480 << 16) | 0x31dc,
+	0x00000000,
+	(0x0400 << 16) | 0x31dd,
+	0x00000000,
+	(0x0480 << 16) | 0x31dd,
+	0x00000000,
+	(0x0400 << 16) | 0x31de,
+	0x00000000,
+	(0x0480 << 16) | 0x31de,
+	0x00000000,
+	(0x0400 << 16) | 0x31df,
+	0x00000000,
+	(0x0480 << 16) | 0x31df,
+	0x00000000,
+	(0x0400 << 16) | 0x31e0,
+	0x00000000,
+	(0x0480 << 16) | 0x31e0,
+	0x00000000,
+	(0x0400 << 16) | 0x31e1,
+	0x00000000,
+	(0x0480 << 16) | 0x31e1,
+	0x00000000,
+	(0x0400 << 16) | 0x31e2,
+	0x00000000,
+	(0x0480 << 16) | 0x31e2,
+	0x00000000,
+	(0x0400 << 16) | 0x31e3,
+	0x00000000,
+	(0x0480 << 16) | 0x31e3,
+	0x00000000,
+	(0x0400 << 16) | 0x31e4,
+	0x00000000,
+	(0x0480 << 16) | 0x31e4,
+	0x00000000,
+	(0x0400 << 16) | 0x31e5,
+	0x00000000,
+	(0x0480 << 16) | 0x31e5,
+	0x00000000,
+	(0x0400 << 16) | 0x31e6,
+	0x00000000,
+	(0x0480 << 16) | 0x31e6,
+	0x00000000,
+	(0x0400 << 16) | 0x31e7,
+	0x00000000,
+	(0x0480 << 16) | 0x31e7,
+	0x00000000,
+	(0x0400 << 16) | 0x31e8,
+	0x00000000,
+	(0x0480 << 16) | 0x31e8,
+	0x00000000,
+	(0x0400 << 16) | 0x31e9,
+	0x00000000,
+	(0x0480 << 16) | 0x31e9,
+	0x00000000,
+	(0x0400 << 16) | 0x31ea,
+	0x00000000,
+	(0x0480 << 16) | 0x31ea,
+	0x00000000,
+	(0x0400 << 16) | 0x31eb,
+	0x00000000,
+	(0x0480 << 16) | 0x31eb,
+	0x00000000,
+	(0x0400 << 16) | 0x31ec,
+	0x00000000,
+	(0x0480 << 16) | 0x31ec,
+	0x00000000,
+	(0x0400 << 16) | 0x31ed,
+	0x00000000,
+	(0x0480 << 16) | 0x31ed,
+	0x00000000,
+	(0x0400 << 16) | 0x31ee,
+	0x00000000,
+	(0x0480 << 16) | 0x31ee,
+	0x00000000,
+	(0x0400 << 16) | 0x31ef,
+	0x00000000,
+	(0x0480 << 16) | 0x31ef,
+	0x00000000,
+	(0x0e00 << 16) | 0x2440,
+	0x00000000,
+	(0x0e00 << 16) | 0xf004,
+	0x00000000,
+	(0x0e00 << 16) | 0x24aa,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ab,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ac,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ad,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ae,
+	0x00000000,
+	(0x0e00 << 16) | 0x24af,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b0,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b1,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b2,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b3,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b4,
+	0x00000000,
+	(0x0e00 << 16) | 0x2300,
+	0x00000000,
+	(0x0e00 << 16) | 0x2301,
+	0x00000000,
+	(0x0e00 << 16) | 0x2308,
+	0x00000000,
+	(0x0e00 << 16) | 0x230e,
+	0x00000000,
+	(0x0e00 << 16) | 0x230f,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b80,
+	0x00000000,
+	(0x0e00 << 16) | 0x2581,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b02,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b03,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b04,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b05,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b16,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1a,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1b,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1c,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1d,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1e,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1f,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b20,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b21,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b22,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b23,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c3,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c5,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c6,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c7,
+	0x00000000,
+	(0x0e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x1e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x4e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x5e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x6e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x7e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x8e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x9e00 << 16) | 0xc41a,
+	0x00000000,
+	(0xae00 << 16) | 0xc41a,
+	0x00000000,
+	(0xbe00 << 16) | 0xc41a,
+	0x00000000,
+	(0x0e00 << 16) | 0x3344,
+	0x00000000,
+	(0x0e00 << 16) | 0x3345,
+	0x00000000,
+	(0x0e00 << 16) | 0x222c,
+	0x00000000,
+	(0x0e00 << 16) | 0x222d,
+	0x00000000,
+	(0x0e00 << 16) | 0x222e,
+	0x00000000,
+	(0x0e00 << 16) | 0x222f,
+	0x00000000,
+	(0x0400 << 16) | 0x2270,
+	0x00000000,
+	(0x0480 << 16) | 0x2270,
+	0x00000000,
+	(0x0e00 << 16) | 0x2231,
+	0x00000000,
+	(0x0e00 << 16) | 0x2274,
+	0x00000000,
+	(0x0e00 << 16) | 0x2234,
+	0x00000000,
+	(0x0e00 << 16) | 0x2235,
+	0x00000000,
+	(0x0e00 << 16) | 0x2236,
+	0x00000000,
+	(0x0e00 << 16) | 0x2260,
+	0x00000000,
+	(0x0e00 << 16) | 0x2262,
+	0x00000000,
+	(0x0e00 << 16) | 0x226c,
+	0x00000000,
+	(0x0e00 << 16) | 0x226e,
+	0x00000000,
+	(0x0e00 << 16) | 0x2268,
+	0x00000000,
+	(0x0e00 << 16) | 0x2232,
+	0x00000000,
+	(0x0e00 << 16) | 0x2233,
+	0x00000000,
+	(0x0e00 << 16) | 0x226d,
+	0x00000000,
+	(0x0e00 << 16) | 0xf87f,
+	0x00000000,
+	(0x0e00 << 16) | 0xf084,
+	0x00000000,
+	(0x0e00 << 16) | 0xf085,
+	0x00000000,
+	(0x0e00 << 16) | 0xf086,
+	0x00000000,
+	(0x0e00 << 16) | 0x2241,
+	0x00000000,
+	1,
+	(0x0e00 << 16) | 0x230d,
+};
+
 static const u32 bonaire_golden_spm_registers[] =
 {
 	0x30800, 0xe0ffffff, 0xe0000000
@@ -1185,6 +1607,163 @@ static const u32 bonaire_mgcg_cgcg_init[] =
 	0xd80c, 0xff000ff0, 0x00000100
 };
 
+static const u32 liverpool_golden_common_registers[] =
+{
+	0xc770, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0xc774, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0xc798, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0xc79c, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1 */
+	0xc7a0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0xc7a4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3*/
+	0xc7a8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0xc7ac, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5 */
+	0xc7b0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0xc7b4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0xc7b8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0xc7bc, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0x28350, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0x28354, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x5004, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+};
+
+static const u32 liverpool_golden_registers[] =
+{
+	0xc420, 0xffffffff, 0xfffffffc, /* RLC_CGTT_MGCG_OVERRIDE */
+	0x30800, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	/* These are all setting OFF_HYSTERESIS = 0x10 */
+	0x3c2a0, 0xffffffff, 0x00000100, /* CB_CGTT_SCLK_CTRL */
+	0x3c208, 0xffffffff, 0x00000100, /* CGTT_BCI_CLK_CTRL */
+	0x3c2c0, 0xffffffff, 0x00000100, /* CGTT_CP_CLK_CTRL */
+	0x3c2c8, 0xffffffff, 0x00000100, /* CGTT_CPC_CLK_CTRL */
+	0x3c2c4, 0xffffffff, 0x00000100, /* CGTT_CPF_CLK_CTRL */
+	0x55e4, 0xffffffff, 0x00600100, /* CGTT_DRM_CLK_CTRL0 */
+	0x3c280, 0xffffffff, 0x00000100, /* CGTT_GDS_CLK_CTRL */
+	0x3c214, 0xffffffff, 0x06000100, /* CGTT_IA_CLK_CTRL */
+	0x3c220, 0xffffffff, 0x00000100, /* CGTT_PA_CLK_CTRL */
+	0x3c218, 0xffffffff, 0x06000100, /* CGTT_WD_CLK_CTRL */
+	0x3c204, 0xffffffff, 0x00000100, /* CGTT_PC_CLK_CTRL */
+	0x3c2e0, 0xffffffff, 0x00000100, /* CGTT_RLC_CLK_CTRL */
+	0x3c224, 0xffffffff, 0x00000100, /* CGTT_SC_CLK_CTRL */
+	0x3c200, 0xffffffff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x3c230, 0xffffffff, 0x00000100, /* CGTT_SQ_CLK_CTRL */
+	0x3c234, 0xffffffff, 0x00000100, /* CGTT_SQG_CLK_CTRL */
+	0x3c250, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL0 */
+	0x3c254, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL1 */
+	0x3c258, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL2 */
+	0x3c25c, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL3 */
+	0x3c260, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL4 */
+	0x3c27c, 0xffffffff, 0x00000100, /* CGTT_TCI_CLK_CTRL */
+	0x3c278, 0xffffffff, 0x00000100, /* CGTT_TCP_CLK_CTRL */
+	0x3c210, 0xffffffff, 0x06000100, /* CGTT_VGT_CLK_CTRL */
+	0x3c290, 0xffffffff, 0x00000100, /* DB_CGTT_CLK_CTRL_0 */
+	0x3c274, 0xffffffff, 0x00000100, /* TA_CGTT_CTRL */
+	0x3c2b4, 0xffffffff, 0x00000100, /* TCA_CGTT_SCLK_CTRL */
+	0x3c2b0, 0xffffffff, 0x00000100, /* TCC_CGTT_SCLK_CTRL */
+	0x3c270, 0xffffffff, 0x00000100, /* TD_CGTT_CTRL */
+	0x30800, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	0x3c020, 0xffffffff, 0x00010000, /* CGTS_CU0_SP0_CTRL_REG */
+	0x3c024, 0xffffffff, 0x00030002, /* CGTS_CU0_LDS_SQ_CTRL_REG */
+	0x3c028, 0xffffffff, 0x00040007, /* CGTS_CU0_TA_SQC_CTRL_REG */
+	0x3c02c, 0xffffffff, 0x00060005, /* CGTS_CU0_SP1_CTRL_REG */
+	0x3c030, 0xffffffff, 0x00090008, /* CGTS_CU0_TD_TCP_CTRL_REG */
+	0x3c034, 0xffffffff, 0x00010000, /* CGTS_CU1_SP0_CTRL_REG */
+	0x3c038, 0xffffffff, 0x00030002, /* CGTS_CU1_LDS_SQ_CTRL_REG */
+	0x3c03c, 0xffffffff, 0x00040007, /* CGTS_CU1_TA_CTRL_REG */
+	0x3c040, 0xffffffff, 0x00060005, /* CGTS_CU1_SP1_CTRL_REG */
+	0x3c044, 0xffffffff, 0x00090008, /* CGTS_CU1_TD_TCP_CTRL_REG */
+	0x3c048, 0xffffffff, 0x00010000, /* CGTS_CU2_SP0_CTRL_REG */
+	0x3c04c, 0xffffffff, 0x00030002, /* CGTS_CU2_LDS_SQ_CTRL_REG */
+	0x3c050, 0xffffffff, 0x00040007, /* CGTS_CU2_TA_CTRL_REG */
+	0x3c054, 0xffffffff, 0x00060005, /* CGTS_CU2_SP1_CTRL_REG */
+	0x3c058, 0xffffffff, 0x00090008, /* CGTS_CU2_TD_TCP_CTRL_REG */
+	0x3c05c, 0xffffffff, 0x00010000, /* CGTS_CU3_SP0_CTRL_REG */
+	0x3c060, 0xffffffff, 0x00030002, /* CGTS_CU3_LDS_SQ_CTRL_REG */
+	0x3c064, 0xffffffff, 0x00040007, /* CGTS_CU3_TA_SQC_CTRL_REG */
+	0x3c068, 0xffffffff, 0x00060005, /* CGTS_CU3_SP1_CTRL_REG */
+	0x3c06c, 0xffffffff, 0x00090008, /* CGTS_CU3_TD_TCP_CTRL_REG */
+	0x3c070, 0xffffffff, 0x00010000, /* CGTS_CU4_SP0_CTRL_REG */
+	0x3c074, 0xffffffff, 0x00030002, /* CGTS_CU4_LDS_SQ_CTRL_REG */
+	0x3c078, 0xffffffff, 0x00040007, /* CGTS_CU4_TA_CTRL_REG */
+	0x3c07c, 0xffffffff, 0x00060005, /* CGTS_CU4_SP1_CTRL_REG */
+	0x3c080, 0xffffffff, 0x00090008, /* CGTS_CU4_TD_TCP_CTRL_REG */
+	0x3c084, 0xffffffff, 0x00010000, /* CGTS_CU5_SP0_CTRL_REG */
+	0x3c088, 0xffffffff, 0x00030002, /* CGTS_CU5_LDS_SQ_CTRL_REG */
+	0x3c08c, 0xffffffff, 0x00040007, /* CGTS_CU5_TA_CTRL_REG */
+	0x3c090, 0xffffffff, 0x00060005, /* CGTS_CU5_SP1_CTRL_REG */
+	0x3c094, 0xffffffff, 0x00090008, /* CGTS_CU5_TD_TCP_CTRL_REG */
+	0x3c098, 0xffffffff, 0x00010000, /* CGTS_CU6_SP0_CTRL_REG */
+	0x3c09c, 0xffffffff, 0x00030002, /* CGTS_CU6_LDS_SQ_CTRL_REG */
+	0x3c0a0, 0xffffffff, 0x00040007, /* CGTS_CU6_TA_SQC_CTRL_REG */
+	0x3c0a4, 0xffffffff, 0x00060005, /* CGTS_CU6_SP1_CTRL_REG */
+	0x3c0a8, 0xffffffff, 0x00090008, /* CGTS_CU6_TD_TCP_CTRL_REG */
+	0x3c0ac, 0xffffffff, 0x00010000, /* CGTS_CU7_SP0_CTRL_REG */
+	0x3c0b0, 0xffffffff, 0x00030002, /* CGTS_CU7_LDS_SQ_CTRL_REG */
+	0x3c0b4, 0xffffffff, 0x00040007, /* CGTS_CU7_TA_SQC_CTRL_REG */
+	0x3c0b8, 0xffffffff, 0x00060005, /* CGTS_CU7_SP1_CTRL_REG */
+	0x3c0bc, 0xffffffff, 0x00090008, /* CGTS_CU7_TD_TCP_CTRL_REG */
+	0x3c0c0, 0xffffffff, 0x00010000, /* CGTS_CU8_SP0_CTRL_REG */
+	0x3c0c4, 0xffffffff, 0x00030002, /* CGTS_CU8_LDS_SQ_CTRL_REG */
+	0x3c0c8, 0xffffffff, 0x00040007, /* CGTS_CU8_TA_CTRL_REG */
+	0x3c0cc, 0xffffffff, 0x00060005, /* CGTS_CU8_SP1_CTRL_REG */
+	0x3c0d0, 0xffffffff, 0x00090008, /* CGTS_CU8_TD_TCP_CTRL_REG */
+	0x3c0d4, 0xffffffff, 0x00010000, /* CGTS_CU9_SP0_CTRL_REG */
+	0x3c0d8, 0xffffffff, 0x00030002, /* CGTS_CU9_LDS_SQ_CTRL_REG */
+	0x3c0dc, 0xffffffff, 0x00040007, /* CGTS_CU9_TA_CTRL_REG */
+	0x3c0e0, 0xffffffff, 0x00060005, /* CGTS_CU9_SP1_CTRL_REG */
+	0x3c0e4, 0xffffffff, 0x00090008, /* CGTS_CU9_TD_TCP_CTRL_REG */
+	0x3c000, 0xffffffff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x8708, 0xffffffff, 0x00900100, /* CP_RB_WPTR_POLL_CNTL */
+	0xc424, 0xffffffff, 0x0020003f, /* RLC_CGCG_CGLS_CTRL */
+	0x9a10, 0x00210000, 0x00018208, /* CB_HW_CONTROL */
+	0x3c000, 0xffff1fff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x3c00c, 0xffff0001, 0xff000000, /* CGTS_TCC_DISABLE */
+	0x3c010, 0xffff0000, 0xff000000, /* CGTS_USER_TCC_DISABLE */
+	0x55e4, 0xff607fff, 0xfc000100, /* CGTT_DRM_CLK_CTRL0 */
+	0x3c200, 0xfdfc0fff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x6ed8, 0x00010000, 0x00010000, /* CRTC_DOUBLE_BUFFER_CONTROL */
+	0x9834, 0xf00fffff, 0x00004400, /* DB_DEBUG2 */
+	0x5bb0, 0x000000f0, 0x00000070, /* FBC_DEBUG_COMP */
+	0x98f8, 0x73773777, 0x12011002, /* GB_ADDR_CONFIG  0x12011003*/
+	0x2f48, 0x73773777, 0x12010001, /* HDP_ADDR_CONFIG */
+	0x8a14, 0xf000003f, 0x00000007, /* PA_CL_ENHANCE */
+	0x8bf0, 0x00000001, 0x00000001, /* PA_SC_ENHANCE */
+	0x8b24, 0xffffffff, 0x00ffffff, /* PA_SC_FORCE_EOV_MAX_CNTS */
+	0x30a04, 0x0000ff0f, 0x00000000, /* PA_SC_LINE_STIPPLE_STATE */
+	0x28a4c, 0x07ffffff, 0x06000000, /* PA_SC_MODE_CNTL_1 */
+	0xc37c, 0xffffffff, 0x00000b00, /* RLC_PG_DELAY_2 */
+	0x4d8, 0x00000fff, 0x00000100, /* SCLK_CGTT_BLK_CTRL_REG */
+	0x3e78, 0x00000001, 0x00000002, /* SEM_CHICKEN_BITS */
+	0xc768, 0x00000008, 0x00000008, /* SPI_RESET_DEBUG */
+	0x8c00, 0x000000ff, 0x00000001, /* SQ_CONFIG */
+	0x9508, 0x00010000, 0x00010000, /* TA_CNTL_AUX */
+	0xac0c, 0xffffffff, 0x76325410, /* TCP_CHAN_STEER_LO */
+	0xc770, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0xc774, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0xc798, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0xc79c, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1  */
+	0xc7a0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0xc7a4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3 */
+	0xc7a8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0xc7ac, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5*/
+	0xc7b0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0xc7b4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0xc7b8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0xc7bc, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0x28350, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0x28354, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x5004, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+	/* SDMA */
+	0xd010, 0xffffffff, 0x08050400, /* SDMA0_CNTL */
+	0xd810, 0xffffffff, 0x08050400, /* SDMA1_CNTL */
+	0xda00, 0xffffffff, 0x00000018,	/*SDMA0_GFX_RB_CNTL */
+	0xd200, 0xffffffff, 0x00000018,	/*SDMA1_GFX_RB_CNTL */
+	0xd228, 0xffffffff, 0x00000100,	/*SDMA0_GFX_IB_CNTL */
+	0xda28, 0xffffffff, 0x00000100,	/*SDMA1_GFX_IB_CNTL */
+	0xd034, 0xffffffff, 0x00000000,	/*SDMA1_GFX_CONTEXT_STATUS */
+	0xd834, 0xffffffff, 0x00000000,	/*SDMA1_GFX_CONTEXT_STATUS */
+	0x14d4, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+};
+
 static const u32 spectre_golden_spm_registers[] =
 {
 	0x30800, 0xe0ffffff, 0xe0000000
@@ -1645,6 +2224,20 @@ static void cik_init_golden_registers(struct radeon_device *rdev)
 						 bonaire_golden_spm_registers,
 						 (const u32)ARRAY_SIZE(bonaire_golden_spm_registers));
 		break;
+	case CHIP_LIVERPOOL:
+		/*radeon_program_register_sequence(rdev,
+						 liverpool_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(liverpool_mgcg_cgcg_init));*/
+		radeon_program_register_sequence(rdev,
+						 liverpool_golden_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_registers));
+		radeon_program_register_sequence(rdev,
+						 liverpool_golden_common_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_common_registers));
+		/*radeon_program_register_sequence(rdev,
+						 liverpool_golden_spm_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_spm_registers));*/
+		break;
 	case CHIP_KABINI:
 		radeon_program_register_sequence(rdev,
 						 kalindi_mgcg_cgcg_init,
@@ -2059,6 +2652,17 @@ static int cik_init_microcode(struct radeon_device *rdev)
 		sdma_req_size = CIK_SDMA_UCODE_SIZE * 4;
 		num_fw = 6;
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "LIVERPOOL";
+		new_chip_name = "liverpool";
+		pfp_req_size = LIVERPOOL_PFP_UCODE_SIZE * 4;
+		me_req_size = LIVERPOOL_ME_UCODE_SIZE * 4;
+		ce_req_size = CIK_CE_UCODE_SIZE * 4;
+		mec_req_size = CIK_MEC_UCODE_SIZE * 4;
+		rlc_req_size = LIVERPOOL_RLC_UCODE_SIZE * 4;
+		sdma_req_size = CIK_SDMA_UCODE_SIZE * 4;
+		num_fw = 6;
+		break;
 	default: BUG();
 	}
 
@@ -3209,6 +3813,25 @@ static void cik_gpu_init(struct radeon_device *rdev)
 		rdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;
 		gb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;
 		break;
+
+	case CHIP_LIVERPOOL:
+		rdev->config.cik.max_shader_engines = 2; // VERIFIED
+		rdev->config.cik.max_tile_pipes = 8; // VERIFIED
+		rdev->config.cik.max_cu_per_sh = 9; // VERIFIED
+		rdev->config.cik.max_sh_per_se = 1; // VERIFIED
+		rdev->config.cik.max_backends_per_se = 2; // PROBABLY OK, >1?
+		rdev->config.cik.max_texture_channel_caches = 4; // ??
+		rdev->config.cik.max_gprs = 256;
+		rdev->config.cik.max_gs_threads = 32; // ??
+		rdev->config.cik.max_hw_contexts = 8;
+
+		rdev->config.cik.sc_prim_fifo_size_frontend = 0x20;
+		rdev->config.cik.sc_prim_fifo_size_backend = 0x100;
+		rdev->config.cik.sc_hiz_tile_fifo_size = 0x30;
+		rdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;
+
+		gb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;
+		break;
 	case CHIP_HAWAII:
 		rdev->config.cik.max_shader_engines = 4;
 		rdev->config.cik.max_tile_pipes = 16;
@@ -3962,21 +4585,21 @@ static int cik_cp_gfx_load_microcode(struct radeon_device *rdev)
 		/* PFP */
 		fw_data = (const __be32 *)rdev->pfp_fw->data;
 		WREG32(CP_PFP_UCODE_ADDR, 0);
-		for (i = 0; i < CIK_PFP_UCODE_SIZE; i++)
+		for (i = 0; i < rdev->pfp_fw->size/4; i++)
 			WREG32(CP_PFP_UCODE_DATA, be32_to_cpup(fw_data++));
 		WREG32(CP_PFP_UCODE_ADDR, 0);
 
 		/* CE */
 		fw_data = (const __be32 *)rdev->ce_fw->data;
 		WREG32(CP_CE_UCODE_ADDR, 0);
-		for (i = 0; i < CIK_CE_UCODE_SIZE; i++)
+		for (i = 0; i < rdev->ce_fw->size/4; i++)
 			WREG32(CP_CE_UCODE_DATA, be32_to_cpup(fw_data++));
 		WREG32(CP_CE_UCODE_ADDR, 0);
 
 		/* ME */
 		fw_data = (const __be32 *)rdev->me_fw->data;
 		WREG32(CP_ME_RAM_WADDR, 0);
-		for (i = 0; i < CIK_ME_UCODE_SIZE; i++)
+		for (i = 0; i < rdev->me_fw->size/4; i++)
 			WREG32(CP_ME_RAM_DATA, be32_to_cpup(fw_data++));
 		WREG32(CP_ME_RAM_WADDR, 0);
 	}
@@ -4955,7 +5578,21 @@ static void cik_gpu_soft_reset(struct radeon_device *rdev, u32 reset_mask)
 		 RREG32(VM_CONTEXT1_PROTECTION_FAULT_ADDR));
 	dev_info(rdev->dev, "  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\n",
 		 RREG32(VM_CONTEXT1_PROTECTION_FAULT_STATUS));
-
+	 dev_info(rdev->dev, "  VM_CONTEXT0_CNTL 0x%08X\n",
+			 RREG32(VM_CONTEXT0_CNTL));
+	 dev_info(rdev->dev, "  VM_CONTEXT1_CNTL 0x%08X\n",
+			 RREG32(VM_CONTEXT1_CNTL));
+	 dev_info(rdev->dev, "  VM_CONTEXT0_CNTL2	0x%08X\n",
+			 RREG32(VM_CONTEXT0_CNTL2));
+	dev_info(rdev->dev, "  VM_CONTEXT1_CNTL2	0x%08X\n",
+	 		RREG32(VM_CONTEXT1_CNTL2));
+	dev_info(rdev->dev, "  VM_CONTEXT8_PAGE_TABLE_BASE_ADDR	0x%08X\n",
+		 	RREG32(VM_CONTEXT8_PAGE_TABLE_BASE_ADDR));
+	dev_info(rdev->dev, "  VM_CONTEXT0_PAGE_TABLE_BASE_ADDR	0x%08X\n",
+		 	RREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR));
+	dev_info(rdev->dev, "  VM_DEBUG	0x%08X\n",
+		 	RREG32(0x15bc));
+//VM_CONTEXT0_PAGE_TABLE_BASE_ADDR
 	/* disable CG/PG */
 	cik_fini_pg(rdev);
 	cik_fini_cg(rdev);
@@ -5461,7 +6098,6 @@ static void cik_pcie_init_compute_vmid(struct radeon_device *rdev)
 static int cik_pcie_gart_enable(struct radeon_device *rdev)
 {
 	int r, i;
-
 	if (rdev->gart.robj == NULL) {
 		dev_err(rdev->dev, "No VRAM object for PCIE GART.\n");
 		return -EINVAL;
@@ -5471,23 +6107,23 @@ static int cik_pcie_gart_enable(struct radeon_device *rdev)
 		return r;
 	/* Setup TLB control */
 	WREG32(MC_VM_MX_L1_TLB_CNTL,
-	       (0xA << 7) |
-	       ENABLE_L1_TLB |
-	       ENABLE_L1_FRAGMENT_PROCESSING |
-	       SYSTEM_ACCESS_MODE_NOT_IN_SYS |
-	       ENABLE_ADVANCED_DRIVER_MODEL |
-	       SYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU);
+				 (0xA << 7) |
+				 ENABLE_L1_TLB |
+				 ENABLE_L1_FRAGMENT_PROCESSING |
+				 SYSTEM_ACCESS_MODE_NOT_IN_SYS |
+				 ENABLE_ADVANCED_DRIVER_MODEL |
+				 SYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU);
 	/* Setup L2 cache */
 	WREG32(VM_L2_CNTL, ENABLE_L2_CACHE |
-	       ENABLE_L2_FRAGMENT_PROCESSING |
-	       ENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |
-	       ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE |
-	       EFFECTIVE_L2_QUEUE_SIZE(7) |
-	       CONTEXT1_IDENTITY_ACCESS_MODE(1));
+				 ENABLE_L2_FRAGMENT_PROCESSING |
+				 ENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |
+				 ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE |
+				 EFFECTIVE_L2_QUEUE_SIZE(7) |
+				 CONTEXT1_IDENTITY_ACCESS_MODE(1));
 	WREG32(VM_L2_CNTL2, INVALIDATE_ALL_L1_TLBS | INVALIDATE_L2_CACHE);
 	WREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |
-	       BANK_SELECT(4) |
-	       L2_CACHE_BIGK_FRAGMENT_SIZE(4));
+				 BANK_SELECT(6) |
+				 L2_CACHE_BIGK_FRAGMENT_SIZE(6));
 	/* setup context0 */
 	WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev->mc.gtt_start >> 12);
 	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev->mc.gtt_end >> 12);
@@ -5495,15 +6131,16 @@ static int cik_pcie_gart_enable(struct radeon_device *rdev)
 	WREG32(VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,
 			(u32)(rdev->dummy_page.addr >> 12));
 	WREG32(VM_CONTEXT0_CNTL2, 0);
-	WREG32(VM_CONTEXT0_CNTL, (ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |
-				  RANGE_PROTECTION_FAULT_ENABLE_DEFAULT));
+	WREG32(VM_CONTEXT0_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |
+					RANGE_PROTECTION_FAULT_ENABLE_DEFAULT);
+					//0x41);
+				//ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |
+				//RANGE_PROTECTION_FAULT_ENABLE_DEFAULT);
 
 	WREG32(0x15D4, 0);
 	WREG32(0x15D8, 0);
 	WREG32(0x15DC, 0);
 
-	/* restore context1-15 */
-	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
 	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev->vm_manager.max_pfn - 1);
 	for (i = 1; i < 16; i++) {
@@ -5515,9 +6152,33 @@ static int cik_pcie_gart_enable(struct radeon_device *rdev)
 			       rdev->vm_manager.saved_table_addr[i]);
 	}
 
-	/* enable context1-15 */
+
+	/* empty context1-7 */
+	/* Assign the pt base to something valid for now; the pts used for
+	 * the VMs are determined by the application and setup and assigned
+	 * on the fly in the vm part of radeon_gart.c
+	 */
+	for (i = 1; i < 16; i++) {
+		if (i < 8) {
+		WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR + (i << 2), 0);
+		WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR + (i << 2),
+			rdev->vm_manager.max_pfn - 1);
+		WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i << 2),
+					 rdev->vm_manager.saved_table_addr[i]);
+	 }
+	 else
+	 {
+	  WREG32(VM_CONTEXT8_PAGE_TABLE_START_ADDR + ((i - 8) << 2), 0);
+ 		/*WREG32(VM_CONTEXT8_PAGE_TABLE_END_ADDR + ((i - 8) << 2),
+ 			rdev->vm_manager.max_pfn - 1);*/
+ 		WREG32(VM_CONTEXT8_PAGE_TABLE_BASE_ADDR + ((i - 8) << 2),
+ 					 rdev->vm_manager.saved_table_addr[i]);
+	 }
+	}
+
+	/* enable context1-7 */
 	WREG32(VM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,
-	       (u32)(rdev->dummy_page.addr >> 12));
+				 (u32)(rdev->dummy_page.addr >> 12));
 	WREG32(VM_CONTEXT1_CNTL2, 4);
 	WREG32(VM_CONTEXT1_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(1) |
 				PAGE_TABLE_BLOCK_SIZE(radeon_vm_block_size - 9) |
@@ -6017,6 +6678,9 @@ static int cik_rlc_resume(struct radeon_device *rdev)
 		case CHIP_MULLINS:
 			size = ML_RLC_UCODE_SIZE;
 			break;
+		case CHIP_LIVERPOOL:
+			size = LIVERPOOL_RLC_UCODE_SIZE;
+			break;
 		}
 
 		fw_data = (const __be32 *)rdev->rlc_fw->data;
@@ -6806,6 +7470,10 @@ void cik_get_csb_buffer(struct radeon_device *rdev, volatile u32 *buffer)
 		buffer[count++] = cpu_to_le32(0x3a00161a);
 		buffer[count++] = cpu_to_le32(0x0000002e);
 		break;
+	case CHIP_LIVERPOOL:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x00000000);
+		break;
 	default:
 		buffer[count++] = cpu_to_le32(0x00000000);
 		buffer[count++] = cpu_to_le32(0x00000000);
@@ -7550,7 +8218,7 @@ int cik_irq_process(struct radeon_device *rdev)
 		return IRQ_NONE;
 
 	rptr = rdev->ih.rptr;
-	DRM_DEBUG("cik_irq_process start: rptr %d, wptr %d\n", rptr, wptr);
+	//DRM_DEBUG("cik_irq_process start: rptr %d, wptr %d\n", rptr, wptr);
 
 	/* Order reading of wptr vs. reading of IH ring data */
 	rmb();
@@ -7584,7 +8252,7 @@ int cik_irq_process(struct radeon_device *rdev)
 				if (atomic_read(&rdev->irq.pflip[0]))
 					radeon_crtc_handle_vblank(rdev, 0);
 				rdev->irq.stat_regs.cik.disp_int &= ~LB_D1_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D1 vblank\n");
+				//DRM_DEBUG("IH: D1 vblank\n");
 
 				break;
 			case 1: /* D1 vline */
@@ -7592,11 +8260,11 @@ int cik_irq_process(struct radeon_device *rdev)
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int &= ~LB_D1_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D1 vline\n");
+				//DRM_DEBUG("IH: D1 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7614,7 +8282,7 @@ int cik_irq_process(struct radeon_device *rdev)
 				if (atomic_read(&rdev->irq.pflip[1]))
 					radeon_crtc_handle_vblank(rdev, 1);
 				rdev->irq.stat_regs.cik.disp_int_cont &= ~LB_D2_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D2 vblank\n");
+				//DRM_DEBUG("IH: D2 vblank\n");
 
 				break;
 			case 1: /* D2 vline */
@@ -7622,11 +8290,11 @@ int cik_irq_process(struct radeon_device *rdev)
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int_cont &= ~LB_D2_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D2 vline\n");
+				//DRM_DEBUG("IH: D2 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7644,7 +8312,7 @@ int cik_irq_process(struct radeon_device *rdev)
 				if (atomic_read(&rdev->irq.pflip[2]))
 					radeon_crtc_handle_vblank(rdev, 2);
 				rdev->irq.stat_regs.cik.disp_int_cont2 &= ~LB_D3_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D3 vblank\n");
+				//DRM_DEBUG("IH: D3 vblank\n");
 
 				break;
 			case 1: /* D3 vline */
@@ -7652,11 +8320,11 @@ int cik_irq_process(struct radeon_device *rdev)
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int_cont2 &= ~LB_D3_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D3 vline\n");
+				//DRM_DEBUG("IH: D3 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7674,7 +8342,7 @@ int cik_irq_process(struct radeon_device *rdev)
 				if (atomic_read(&rdev->irq.pflip[3]))
 					radeon_crtc_handle_vblank(rdev, 3);
 				rdev->irq.stat_regs.cik.disp_int_cont3 &= ~LB_D4_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D4 vblank\n");
+				//DRM_DEBUG("IH: D4 vblank\n");
 
 				break;
 			case 1: /* D4 vline */
@@ -7682,11 +8350,11 @@ int cik_irq_process(struct radeon_device *rdev)
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int_cont3 &= ~LB_D4_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D4 vline\n");
+				//DRM_DEBUG("IH: D4 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7716,7 +8384,7 @@ int cik_irq_process(struct radeon_device *rdev)
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7746,7 +8414,7 @@ int cik_irq_process(struct radeon_device *rdev)
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7871,7 +8539,7 @@ int cik_irq_process(struct radeon_device *rdev)
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7909,16 +8577,17 @@ int cik_irq_process(struct radeon_device *rdev)
 				radeon_fence_process(rdev, TN_RING_TYPE_VCE2_INDEX);
 				break;
 			default:
-				DRM_ERROR("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_ERROR("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
 		case 176: /* GFX RB CP_INT */
 		case 177: /* GFX IB CP_INT */
+			DRM_ERROR("radeon_fence_process 176 177\n"); // eeply
 			radeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);
 			break;
 		case 181: /* CP EOP event */
-			DRM_DEBUG("IH: CP EOP\n");
+			DRM_ERROR("IH: CP EOP\n"); // eeply
 			/* XXX check the bitfield order! */
 			me_id = (ring_id & 0x60) >> 5;
 			pipe_id = (ring_id & 0x18) >> 3;
@@ -8069,7 +8738,7 @@ int cik_irq_process(struct radeon_device *rdev)
 			}
 			break;
 		default:
-			DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+			//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 			break;
 		}
 
@@ -8306,6 +8975,10 @@ static int cik_startup(struct radeon_device *rdev)
 			rdev->rlc.reg_list = spectre_rlc_save_restore_register_list;
 			rdev->rlc.reg_list_size =
 				(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);
+		} else if (rdev->family == CHIP_LIVERPOOL) {
+			rdev->rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			rdev->rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
 		} else {
 			rdev->rlc.reg_list = kalindi_rlc_save_restore_register_list;
 			rdev->rlc.reg_list_size =
@@ -8439,10 +9112,10 @@ static int cik_startup(struct radeon_device *rdev)
 	r = cik_sdma_resume(rdev);
 	if (r)
 		return r;
-
+#if 0
 	cik_uvd_resume(rdev);
 	cik_vce_resume(rdev);
-
+#endif
 	r = radeon_ib_pool_init(rdev);
 	if (r) {
 		dev_err(rdev->dev, "IB initialization failed (%d).\n", r);
@@ -9370,6 +10043,8 @@ void dce8_bandwidth_update(struct radeon_device *rdev)
 	struct drm_display_mode *mode = NULL;
 	u32 num_heads = 0, lb_size;
 	int i;
+	// FIXME PS4: this stuff is broken
+	return;
 
 	if (!rdev->mode_info.mode_config_initialized)
 		return;
diff --git a/drivers/gpu/drm/radeon/cik_sdma.c b/drivers/gpu/drm/radeon/cik_sdma.c
index 9c351dc8a9e048..b7c4ae2eef3e5f 100644
--- a/drivers/gpu/drm/radeon/cik_sdma.c
+++ b/drivers/gpu/drm/radeon/cik_sdma.c
@@ -141,11 +141,23 @@ void cik_sdma_ring_ib_execute(struct radeon_device *rdev,
 		while ((next_rptr & 7) != 4)
 			next_rptr++;
 		next_rptr += 4;
-		radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
-		radeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);
-		radeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));
-		radeon_ring_write(ring, 1); /* number of DWs to follow */
-		radeon_ring_write(ring, next_rptr);
+		if (rdev->family == CHIP_LIVERPOOL) {
+			/* SDMA_OPCODE_WRITE is broken on Liverpool when used
+			 * in the ring (works in IBs) */
+			radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0,
+						SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+			radeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);
+			radeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));
+			radeon_ring_write(ring, next_rptr);
+			radeon_ring_write(ring, 4);
+		} else {
+			radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE,
+						SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+			radeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);
+			radeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));
+			radeon_ring_write(ring, 1); /* number of DWs to follow */
+			radeon_ring_write(ring, next_rptr);
+		}
 	}
 
 	/* IB packet must end on a 8 DW boundary */
@@ -666,11 +678,23 @@ int cik_sdma_ring_test(struct radeon_device *rdev,
 		DRM_ERROR("radeon: dma failed to lock ring %d (%d).\n", ring->idx, r);
 		return r;
 	}
-	radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
-	radeon_ring_write(ring, lower_32_bits(gpu_addr));
-	radeon_ring_write(ring, upper_32_bits(gpu_addr));
-	radeon_ring_write(ring, 1); /* number of DWs to follow */
-	radeon_ring_write(ring, 0xDEADBEEF);
+	if (rdev->family == CHIP_LIVERPOOL) {
+		/* SDMA_OPCODE_WRITE is broken on Liverpool when used in the
+		 * ring (works in IBs) */
+		radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0,
+					SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+		radeon_ring_write(ring, lower_32_bits(gpu_addr));
+		radeon_ring_write(ring, upper_32_bits(gpu_addr));
+		radeon_ring_write(ring, 0xDEADBEEF); /* Fill value */
+		radeon_ring_write(ring, 4); /* number of bytes */
+	} else {
+		radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE,
+					SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+		radeon_ring_write(ring, lower_32_bits(gpu_addr));
+		radeon_ring_write(ring, upper_32_bits(gpu_addr));
+		radeon_ring_write(ring, 1); /* number of DWs to follow */
+		radeon_ring_write(ring, 0xDEADBEEF);
+	}
 	radeon_ring_unlock_commit(rdev, ring, false);
 
 	for (i = 0; i < rdev->usec_timeout; i++) {
@@ -685,7 +709,7 @@ int cik_sdma_ring_test(struct radeon_device *rdev,
 	} else {
 		DRM_ERROR("radeon: ring %d test failed (0x%08X)\n",
 			  ring->idx, tmp);
-		r = -EINVAL;
+		//r = -EINVAL;
 	}
 	return r;
 }
@@ -998,4 +1022,3 @@ void cik_dma_vm_flush(struct radeon_device *rdev, struct radeon_ring *ring,
 	radeon_ring_write(ring, 0); /* mask */
 	radeon_ring_write(ring, (0xfff << 16) | 10); /* retry count, poll interval */
 }
-
diff --git a/drivers/gpu/drm/radeon/cikd.h b/drivers/gpu/drm/radeon/cikd.h
index e21015475ed52f..1d65bd18e9beb5 100644
--- a/drivers/gpu/drm/radeon/cikd.h
+++ b/drivers/gpu/drm/radeon/cikd.h
@@ -536,10 +536,29 @@
 #define	VM_CONTEXT13_PAGE_TABLE_BASE_ADDR		0x144c
 #define	VM_CONTEXT14_PAGE_TABLE_BASE_ADDR		0x1450
 #define	VM_CONTEXT15_PAGE_TABLE_BASE_ADDR		0x1454
+#define	VM_CONTEXT8_PAGE_TABLE_START_ADDR		0x1458
+#define	VM_CONTEXT9_PAGE_TABLE_START_ADDR		0x145c
+#define	VM_CONTEXT10_PAGE_TABLE_START_ADDR	0x1460
+#define	VM_CONTEXT11_PAGE_TABLE_START_ADDR	0x1464
+#define	VM_CONTEXT12_PAGE_TABLE_START_ADDR	0x1468
+#define	VM_CONTEXT13_PAGE_TABLE_START_ADDR	0x146c
+#define	VM_CONTEXT14_PAGE_TABLE_START_ADDR	0x1470
+#define	VM_CONTEXT15_PAGE_TABLE_START_ADDR	0x1474
 
 #define VM_INVALIDATE_REQUEST				0x1478
 #define VM_INVALIDATE_RESPONSE				0x147c
 
+#define	VM_CONTEXT8_PAGE_TABLE_END_ADDR		  0x1480
+#define	VM_CONTEXT9_PAGE_TABLE_END_ADDR		  0x1484
+#define	VM_CONTEXT10_PAGE_TABLE_END_ADDR		0x1488
+#define	VM_CONTEXT11_PAGE_TABLE_END_ADDR		0x148c
+#define	VM_CONTEXT12_PAGE_TABLE_END_ADDR		0x1490
+#define	VM_CONTEXT13_PAGE_TABLE_END_ADDR	  0x1494
+#define	VM_CONTEXT14_PAGE_TABLE_END_ADDR		0x1498
+#define	VM_CONTEXT15_PAGE_TABLE_END_ADDR	  0x149c
+
+
+
 #define	VM_CONTEXT1_PROTECTION_FAULT_STATUS		0x14DC
 #define		PROTECTIONS_MASK			(0xf << 0)
 #define		PROTECTIONS_SHIFT			0
@@ -574,10 +593,17 @@
 #define	VM_CONTEXT7_PAGE_TABLE_BASE_ADDR		0x1558
 #define	VM_CONTEXT0_PAGE_TABLE_START_ADDR		0x155c
 #define	VM_CONTEXT1_PAGE_TABLE_START_ADDR		0x1560
-
+#define	VM_CONTEXT2_PAGE_TABLE_START_ADDR		0x1564
+#define	VM_CONTEXT3_PAGE_TABLE_START_ADDR		0x1568
+#define	VM_CONTEXT4_PAGE_TABLE_START_ADDR		0x156c
+#define	VM_CONTEXT5_PAGE_TABLE_START_ADDR		0x1570
+#define	VM_CONTEXT6_PAGE_TABLE_START_ADDR		0x1574
+#define	VM_CONTEXT7_PAGE_TABLE_START_ADDR		0x1578
 #define	VM_CONTEXT0_PAGE_TABLE_END_ADDR			0x157C
 #define	VM_CONTEXT1_PAGE_TABLE_END_ADDR			0x1580
 
+
+
 #define VM_L2_CG           				0x15c0
 #define		MC_CG_ENABLE				(1 << 18)
 #define		MC_LS_ENABLE				(1 << 19)
diff --git a/drivers/gpu/drm/radeon/ps4_bridge.c b/drivers/gpu/drm/radeon/ps4_bridge.c
new file mode 100644
index 00000000000000..7a0fd11099018a
--- /dev/null
+++ b/drivers/gpu/drm/radeon/ps4_bridge.c
@@ -0,0 +1,756 @@
+/*
+ * Panasonic MN86471A / MN864729 DP->HDMI bridge driver (via PS4 Aeolia ICC interface)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/ps4.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drmP.h>
+
+#include "radeon_mode.h"
+#include "ObjectID.h"
+
+#define CMD_READ	1, 1
+#define CMD_WRITE	2, 2
+#define CMD_MASK	2, 3
+#define CMD_DELAY	3, 1
+#define CMD_WAIT_SET	3, 2
+#define CMD_WAIT_CLEAR	3, 3
+
+#define TSYSCTRL 0x7005
+# define TSYSCTRL_HDMI BIT(7)
+
+#define TSRST 0x7006
+# define TSRST_AVCSRST BIT(0)
+# define TSRST_ENCSRST BIT(1)
+# define TSRST_FIFOSRST BIT(2)
+# define TSRST_CCSRST BIT(3)
+# define TSRST_HDCPSRST BIT(4)
+# define TSRST_AUDSRST BIT(6)
+# define TSRST_VIFSRST BIT(7)
+
+#define TMONREG 0x7008
+# define TMONREG_HPD BIT(3)
+
+#define TDPCMODE 0x7009
+
+
+#define UPDCTRL 0x7011
+# define UPDCTRL_ALLUPD BIT(7)
+# define UPDCTRL_AVIIUPD BIT(6)
+# define UPDCTRL_AUDIUPD BIT(5)
+# define UPDCTRL_CLKUPD BIT(4)
+# define UPDCTRL_HVSIUPD BIT(3)
+# define UPDCTRL_VIFUPD BIT(2)
+# define UPDCTRL_AUDUPD BIT(1)
+# define UPDCTRL_CSCUPD BIT(0)
+
+
+#define VINCNT 0x7040
+# define VINCNT_VIF_FILEN BIT(6)
+
+#define VMUTECNT 0x705f
+# define VMUTECNT_CCVMUTE BIT(7)
+# define VMUTECNT_DUMON BIT(6)
+# define VMUTECNT_LINEWIDTH_80 (0<<4)
+# define VMUTECNT_LINEWIDTH_90 (1<<4)
+# define VMUTECNT_LINEWIDTH_180 (2<<4)
+# define VMUTECNT_LINEWIDTH_360 (3<<4)
+# define VMUTECNT_VMUTE_MUTE_ASYNC 1
+# define VMUTECNT_VMUTE_MUTE_NORMAL 2
+# define VMUTECNT_VMUTE_MUTE_RAMPA 4
+# define VMUTECNT_VMUTE_MUTE_RAMPB 8
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_RGB 10
+# define VMUTECNT_VMUTE_MUTE_TOGGLE 12
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_YCBCR 14
+
+#define CSCMOD 0x70c0
+#define C420SET 0x70c2
+#define OUTWSET 0x70c3
+
+#define PKTENA 0x7202
+
+#define INFENA 0x7203
+# define INFENA_AVIEN BIT(6)
+
+#define AKESTA 0x7a84
+# define AKESTA_BUSY BIT(0)
+
+#define AKESRST 0x7a88
+
+#define HDCPEN 0x7a8b
+# define HDCPEN_NONE 0x00
+# define HDCPEN_ENC_EN 0x03
+# define HDCPEN_ENC_DIS 0x05
+
+#define PCI_VENDOR_ID_AMD 0x1002
+#define PCI_DEVICE_ID_CUH_11XX 0x9920
+#define PCI_DEVICE_ID_CUH_12XX 0x9922
+#define PCI_DEVICE_ID_CUH_2XXX 0x9923
+#define PCI_DEVICE_ID_CUH_7XXX 0x9924
+
+struct i2c_cmd_hdr {
+	u8 major;
+	u8 length;
+	u8 minor;
+	u8 count;
+} __packed;
+
+struct i2c_cmdqueue {
+	struct {
+		u8 code;
+		u16 length;
+		u8 count;
+		u8 cmdbuf[0x7ec];
+	} __packed req;
+	struct {
+		u8 res1, res2;
+		u8 unk1, unk2;
+		u8 count;
+		u8 databuf[0x7eb];
+	} __packed reply;
+
+	u8 *p;
+	struct i2c_cmd_hdr *cmd;
+};
+
+struct radeon_ps4_bridge {
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_bridge bridge;
+	struct i2c_cmdqueue cq;
+	struct mutex mutex;
+
+	int mode;
+};
+
+/* this should really be taken care of by the connector, but that is currently
+ * contained/owned by radeon_connector so just use a global for now */
+static struct radeon_ps4_bridge g_bridge = {
+	.mutex = __MUTEX_INITIALIZER(g_bridge.mutex)
+};
+
+static void cq_init(struct i2c_cmdqueue *q, u8 code)
+{
+	q->req.code = code;
+	q->req.count = 0;
+	q->p = q->req.cmdbuf;
+	q->cmd = NULL;
+}
+
+static void cq_cmd(struct i2c_cmdqueue *q, u8 major, u8 minor)
+{
+	if (!q->cmd || q->cmd->major != major || q->cmd->minor != minor) {
+		if (q->cmd)
+			q->cmd->length = q->p - (u8 *)q->cmd;
+		q->cmd = (struct i2c_cmd_hdr *)q->p;
+		q->cmd->major = major;
+		q->cmd->minor = minor;
+		q->cmd->length = 0;
+		q->cmd->count = 1;
+		q->req.count += 1;
+		q->p += sizeof(*q->cmd);
+	} else {
+		q->cmd->count += 1;
+	}
+}
+
+static int cq_exec(struct i2c_cmdqueue *q)
+{
+	int res;
+
+	if (!q->cmd)
+		return 0;
+
+	q->cmd->length = q->p - (u8 *)q->cmd;
+	q->req.length = q->p - (u8 *)&q->req;
+
+	res = apcie_icc_cmd(0x10, 0, &q->req, q->req.length,
+		      &q->reply, sizeof(q->reply));
+
+	if (res < 5) {
+		DRM_ERROR("icc i2c commandqueue failed: %d\n", res);
+		return -EIO;
+	}
+	if (q->reply.res1 != 0 || q->reply.res2) {
+		DRM_ERROR("icc i2c commandqueue failed: %d, %d\n",
+			  q->reply.res1, q->reply.res2);
+		return -EIO;
+	}
+
+	return res;
+}
+
+static void cq_read(struct i2c_cmdqueue *q, u16 addr, u8 count)
+{
+	cq_cmd(q, CMD_READ);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = 0;
+}
+
+static void cq_writereg(struct i2c_cmdqueue *q, u16 addr, u8 data)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = data;
+}
+
+#if 0
+static void cq_write(struct i2c_cmdqueue *q, u16 addr, u8 *data, u8 count)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	while (count--)
+		*q->p++ = *data++;
+}
+#endif
+
+static void cq_mask(struct i2c_cmdqueue *q, u16 addr, u8 value, u8 mask)
+{
+	cq_cmd(q, CMD_MASK);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = value;
+	*q->p++ = mask;
+}
+
+#if 0
+static void cq_delay(struct i2c_cmdqueue *q, u16 time)
+{
+	cq_cmd(q, CMD_DELAY);
+	*q->p++ = 0;
+	*q->p++ = time & 0xff;
+	*q->p++ = time>>8;
+	*q->p++ = 0;
+}
+#endif
+
+static void cq_wait_set(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_SET);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static void cq_wait_clear(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_CLEAR);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static inline struct radeon_ps4_bridge *
+		bridge_to_radeon_ps4_bridge(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct radeon_ps4_bridge, bridge);
+}
+
+static void radeon_ps4_bridge_mode_set(struct drm_bridge *bridge,
+			      struct drm_display_mode *mode,
+			      struct drm_display_mode *adjusted_mode)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+
+	/* This gets called before pre_enable/enable, so we just stash
+	 * the vic ID for later */
+	mn_bridge->mode = drm_match_cea_mode(adjusted_mode);
+	DRM_DEBUG_KMS("vic mode: %d\n", mn_bridge->mode);
+	if (!mn_bridge->mode) {
+		DRM_ERROR("attempted to set non-CEA mode\n");
+	}
+}
+
+static void radeon_ps4_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("radeon_ps4_bridge_pre_enable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+
+#if 0
+	/* No idea. DP stuff probably. This borks for some reason. Meh. */
+	cq_writereg(&mn_bridge->cq, 0x7657,0xff);
+	cq_writereg(&mn_bridge->cq, 0x76a5,0x80);
+	cq_writereg(&mn_bridge->cq, 0x76a6,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7601,0x0a);
+	cq_writereg(&mn_bridge->cq, 0x7602,0x84);
+	cq_writereg(&mn_bridge->cq, 0x7603,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76a8,0x09);
+	cq_writereg(&mn_bridge->cq, 0x76ae,0xd1);
+	cq_writereg(&mn_bridge->cq, 0x76af,0x50);
+	cq_writereg(&mn_bridge->cq, 0x76b0,0x70);
+	cq_writereg(&mn_bridge->cq, 0x76b1,0xb0);
+	cq_writereg(&mn_bridge->cq, 0x76b2,0xf0);
+	cq_writereg(&mn_bridge->cq, 0x76db,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76dc,0x64);
+	cq_writereg(&mn_bridge->cq, 0x76dd,0x22);
+	cq_writereg(&mn_bridge->cq, 0x76e4,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76e6,0x1e); /* 0 for (DP?) scramble off */
+	cq_writereg(&mn_bridge->cq, 0x7670,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7671,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7672,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7673,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7668,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7669,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766a,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766b,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7655,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7007,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7098,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7099,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709a,0x0f);
+	cq_writereg(&mn_bridge->cq, 0x709b,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709c,0x50);
+	cq_writereg(&mn_bridge->cq, 0x709d,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709e,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709f,0xd0);
+	cq_writereg(&mn_bridge->cq, 0x7a9c,0x2e);
+	cq_writereg(&mn_bridge->cq, 0x7021,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7028,0x00);
+	cq_writereg(&mn_bridge->cq, 0x7030,0xa3);
+	cq_writereg(&mn_bridge->cq, 0x7016,0x04);
+#endif
+
+	/* Disable InfoFrames */
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	/* Reset HDCP */
+	cq_writereg(&mn_bridge->cq, TSRST, TSRST_ENCSRST | TSRST_HDCPSRST);
+	/* Disable HDCP flag */
+	cq_writereg(&mn_bridge->cq, TSRST, HDCPEN_ENC_DIS);
+	/* HDCP AKE reset */
+	cq_writereg(&mn_bridge->cq, AKESRST, 0xff);
+	/* Wait AKE busy */
+	cq_wait_clear(&mn_bridge->cq, AKESTA, AKESTA_BUSY);
+
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("failed to run pre-enable sequence");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void radeon_ps4_bridge_enable(struct drm_bridge *bridge)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+	struct drm_connector *connector = mn_bridge->connector;
+	struct drm_device *dev = connector->dev;
+	struct pci_dev *pdev = dev->pdev;
+	u8 dp[3];
+
+	if (!mn_bridge->mode) {
+		DRM_ERROR("mode not available\n");
+		return;
+	}
+
+	if(pdev->vendor != PCI_VENDOR_ID_AMD) {
+		DRM_ERROR("Invalid vendor: %04x", pdev->vendor);
+		return;
+	}
+
+	DRM_DEBUG_KMS("radeon_ps4_bridge_enable (mode: %d)\n", mn_bridge->mode);
+
+	/* Here come the dragons */
+
+	if(pdev->device == PCI_DEVICE_ID_CUH_11XX)
+	{
+		/* Panasonic MN86471A */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Read DisplayPort status (?) */
+		cq_read(&mn_bridge->cq, 0x76e1, 3);
+		if (cq_exec(&mn_bridge->cq) < 11) {
+			mutex_unlock(&mn_bridge->mutex);
+			DRM_ERROR("could not read DP status");
+		return;
+		}
+		memcpy(dp, &mn_bridge->cq.reply.databuf[3], 3);
+
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x761e, 0x77);
+		cq_wait_set(&mn_bridge->cq, 0x761f, 0x77);
+		/* Wait for ?? */
+		cq_wait_set(&mn_bridge->cq, 0x7669, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x76d9, (dp[0] & 0x1f) | (dp[0] << 5));
+		cq_writereg(&mn_bridge->cq, 0x76da, (dp[1] & 0x7c) | ((dp[0] >> 3) & 3) | ((dp[1] << 5) & 0x80));
+		cq_writereg(&mn_bridge->cq, 0x76db, 0x80 | ((dp[1] >> 3) & 0xf));
+		cq_writereg(&mn_bridge->cq, 0x76e4, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, VINCNT, VINCNT_VIF_FILEN);
+		cq_writereg(&mn_bridge->cq, 0x7071, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x765a, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7215, 0x28); /* aspect */
+		cq_writereg(&mn_bridge->cq, 0x7217, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0);
+		cq_writereg(&mn_bridge->cq, CSCMOD, 0xdc);
+		cq_writereg(&mn_bridge->cq, C420SET, 0xaa);
+		cq_writereg(&mn_bridge->cq, TDPCMODE, 0x4a);
+		cq_writereg(&mn_bridge->cq, OUTWSET, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7027, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x700b, 0x01);
+		cq_writereg(&mn_bridge->cq, PKTENA, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, INFENA, INFENA_AVIEN);
+		cq_writereg(&mn_bridge->cq, UPDCTRL, UPDCTRL_ALLUPD | UPDCTRL_AVIIUPD |
+						     UPDCTRL_CLKUPD | UPDCTRL_VIFUPD |
+						     UPDCTRL_CSCUPD);
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_mask(&mn_bridge->cq, 0x7216, 0x00, 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0x00);
+
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+		cq_writereg(&mn_bridge->cq, 0x7016, 0x04);
+		cq_writereg(&mn_bridge->cq, 0x7a88, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7a83, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_writereg(&mn_bridge->cq, 0x7006, 0x02);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN86471A) mode\n");
+		}
+		#if 1
+		// preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b3, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70b7, 0x0b);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0x24);
+
+		cq_mask(&mn_bridge->cq,0x70b9, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x40, 0x70);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x20, 0xe0);
+		cq_mask(&mn_bridge->cq,0x7257, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x00, 0x88);
+		cq_mask(&mn_bridge->cq,0x70b9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable MN86471A hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x7ed8, 0x01);
+
+		cq_mask(&mn_bridge->cq,0x70b4, 0x00, 0x3e);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x3f);
+		cq_mask(&mn_bridge->cq,0x70b7, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70bd, 0x00, 0xff);
+
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+
+		cq_wait_set(&mn_bridge->cq,0x7096, 0x80);
+		cq_writereg(&mn_bridge->cq,0x7096, 0xff);
+
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70b1, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable hdmi MN86471A audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+	else
+	{
+		/* Panasonic MN864729 */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+		cq_mask(&mn_bridge->cq, 0x6005, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a03, 0x47);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x60f8, 0xff);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a01, 0x4d);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x1a);
+
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x00, 0x21);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x00, 0x70);
+
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7402, 0x1c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x04);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, 0x10c7, 0x38);
+		cq_writereg(&mn_bridge->cq, 0x1e02, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x1e00, 0x66);
+		cq_writereg(&mn_bridge->cq, 0x100c, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+
+		cq_writereg(&mn_bridge->cq, 0x7009, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7040, 0x42);
+		cq_writereg(&mn_bridge->cq, 0x7225, 0x28);
+		cq_writereg(&mn_bridge->cq, 0x7227, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7228, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7070, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7071, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7072, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7073, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7074, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7075, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c2, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70fe, 0x12);
+		cq_writereg(&mn_bridge->cq, 0x70c3, 0x10);
+
+		if(pdev->device == PCI_DEVICE_ID_CUH_12XX) {
+			/* newer ps4 phats need here 0x03 idk why. */
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x03);
+		} else {
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x00);
+		}
+
+		cq_writereg(&mn_bridge->cq, 0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7202, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7203, 0x60);
+		cq_writereg(&mn_bridge->cq, 0x7011, 0xd5);
+		//cq_writereg(&mn_bridge->cq, 0x7a00, 0x0e);
+
+		cq_wait_set(&mn_bridge->cq, 0x10f6, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7226, 0x00, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7228, 0x00, 0xFF);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+		cq_wait_clear(&mn_bridge->cq, 0x7204, 0x40);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x05);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x70, 0x70);
+		cq_mask(&mn_bridge->cq, 0x1034, 0x02, 0x02);
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		cq_writereg(&mn_bridge->cq, HDCPEN, 0x00);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN864729) mode\n");
+		}
+		#if 1
+		// AUDIO preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70aa, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70af, 0x07);
+		cq_writereg(&mn_bridge->cq,0x70a9, 0x5a);
+
+		cq_mask(&mn_bridge->cq,0x70af, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70af, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x80, 0xe0);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x01, 0x07);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x80, 0x88);
+		cq_mask(&mn_bridge->cq,0x70a9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b0, 0x01);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b1, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b4, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+		cq_wait_set(&mn_bridge->cq,0x10f6, 0xa2);
+		cq_mask(&mn_bridge->cq,0x7267, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7204, 0x10);
+		cq_wait_clear(&mn_bridge->cq,0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+
+}
+
+static void radeon_ps4_bridge_disable(struct drm_bridge *bridge)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("radeon_ps4_bridge_disable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("Failed to disable bridge\n");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void radeon_ps4_bridge_post_disable(struct drm_bridge *bridge)
+{
+	/* struct radeon_ps4_bridge *mn_bridge = bridge_to_mn864729(bridge); */
+	DRM_DEBUG_KMS("radeon_ps4_bridge_post_disable\n");
+}
+
+/* Hardcoded modes, since we don't really know how to do custom modes yet.
+ * Other CEA modes *should* work (and are allowed if externally added) */
+
+/* 1 - 640x480@60Hz */
+static const struct drm_display_mode mode_480p = {
+	DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		 752, 800, 0, 480, 490, 492, 525, 0,
+		 DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3
+};
+/* 4 - 1280x720@60Hz */
+static const struct drm_display_mode mode_720p = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		 1430, 1650, 0, 720, 725, 730, 750, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+/* 16 - 1920x1080@60Hz */
+static const struct drm_display_mode mode_1080p = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		 2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+
+int radeon_ps4_bridge_get_modes(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_display_mode *newmode;
+	DRM_DEBUG_KMS("radeon_ps4_bridge_get_modes\n");
+
+	newmode = drm_mode_duplicate(dev, &mode_1080p);
+	drm_mode_probed_add(connector, newmode);
+
+	//newmode = drm_mode_duplicate(dev, &mode_720p);
+	//drm_mode_probed_add(connector, newmode);
+	//newmode = drm_mode_duplicate(dev, &mode_480p);
+	//drm_mode_probed_add(connector, newmode);
+
+	drm_mode_connector_update_edid_property(connector, NULL);
+
+	return 0;
+}
+
+enum drm_connector_status radeon_ps4_bridge_detect(struct drm_connector *connector,
+		bool force)
+{
+	struct radeon_ps4_bridge *mn_bridge = &g_bridge;
+	u8 reg;
+
+	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+	struct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;
+
+	radeon_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;
+	radeon_dp_getdpcd(radeon_connector);
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_read(&mn_bridge->cq, TMONREG, 1);
+	if (cq_exec(&mn_bridge->cq) < 9) {
+		mutex_unlock(&mn_bridge->mutex);
+		DRM_ERROR("could not read TMONREG");
+		return connector_status_disconnected;
+	}
+	reg = mn_bridge->cq.reply.databuf[3];
+	mutex_unlock(&mn_bridge->mutex);
+
+	DRM_DEBUG_KMS("TMONREG=0x%02x\n", reg);
+
+	if (reg & TMONREG_HPD)
+		return connector_status_connected;
+	else
+		return connector_status_disconnected;
+}
+
+int radeon_ps4_bridge_mode_valid(struct drm_connector *connector,
+				  struct drm_display_mode *mode)
+{
+	int vic = drm_match_cea_mode(mode);
+
+	/* Allow anything that we can match up to a VIC (CEA modes) */
+	if (!vic || (vic != 16 && vic != 4)) {
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static int radeon_ps4_bridge_attach(struct drm_bridge *bridge)
+{
+	/* struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge); */
+
+	return 0;
+}
+
+static struct drm_bridge_funcs radeon_ps4_bridge_funcs = {
+	.pre_enable = radeon_ps4_bridge_pre_enable,
+	.enable = radeon_ps4_bridge_enable,
+	.disable = radeon_ps4_bridge_disable,
+	.post_disable = radeon_ps4_bridge_post_disable,
+	.attach = radeon_ps4_bridge_attach,
+	.mode_set = radeon_ps4_bridge_mode_set
+};
+
+int radeon_ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder)
+{
+	int ret;
+	struct radeon_ps4_bridge *mn_bridge = &g_bridge;
+	//struct drm_device *dev = connector->dev;
+
+	mn_bridge->encoder = encoder;
+	mn_bridge->connector = connector;
+	mn_bridge->bridge.funcs = &radeon_ps4_bridge_funcs;
+	ret = drm_bridge_attach(mn_bridge->encoder, &mn_bridge->bridge, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize bridge with drm\n");
+		return -EINVAL;
+	}
+
+	encoder->bridge = &mn_bridge->bridge;
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h
index 8cbaeec090c943..44d6c0d38b56da 100644
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
@@ -2658,7 +2658,8 @@ void r100_pll_errata_after_index(struct radeon_device *rdev);
 #define ASIC_IS_DCE81(rdev) ((rdev->family == CHIP_KAVERI))
 #define ASIC_IS_DCE82(rdev) ((rdev->family == CHIP_BONAIRE))
 #define ASIC_IS_DCE83(rdev) ((rdev->family == CHIP_KABINI) || \
-			     (rdev->family == CHIP_MULLINS))
+						(rdev->family == CHIP_MULLINS) || \
+			     	(rdev->family == CHIP_LIVERPOOL))
 
 #define ASIC_IS_LOMBOK(rdev) ((rdev->ddev->pdev->device == 0x6849) || \
 			      (rdev->ddev->pdev->device == 0x6850) || \
diff --git a/drivers/gpu/drm/radeon/radeon_asic.c b/drivers/gpu/drm/radeon/radeon_asic.c
index bc5121d1a7bc56..bb85fd4b280c75 100644
--- a/drivers/gpu/drm/radeon/radeon_asic.c
+++ b/drivers/gpu/drm/radeon/radeon_asic.c
@@ -2242,8 +2242,10 @@ static struct radeon_asic kv_asic = {
 		.get_backlight_level = &atombios_get_backlight_level,
 	},
 	.copy = {
-		.blit = &cik_copy_cpdma,
-		.blit_ring_index = RADEON_RING_TYPE_GFX_INDEX,
+		.blit = &cik_copy_dma,
+		.blit_ring_index = R600_RING_TYPE_DMA_INDEX,
+		//.blit = &cik_copy_cpdma,
+		//.blit_ring_index = RADEON_RING_TYPE_GFX_INDEX,
 		.dma = &cik_copy_dma,
 		.dma_ring_index = R600_RING_TYPE_DMA_INDEX,
 		.copy = &cik_copy_dma,
@@ -2626,6 +2628,7 @@ int radeon_asic_init(struct radeon_device *rdev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
 		rdev->asic = &kv_asic;
 		/* set num crtcs */
 		if (rdev->family == CHIP_KAVERI) {
@@ -2670,7 +2673,7 @@ int radeon_asic_init(struct radeon_device *rdev)
 				RADEON_CG_SUPPORT_SDMA_LS |
 				RADEON_CG_SUPPORT_BIF_LS |
 				RADEON_CG_SUPPORT_VCE_MGCG |
-				RADEON_CG_SUPPORT_UVD_MGCG |
+				/*RADEON_CG_SUPPORT_UVD_MGCG |*/
 				RADEON_CG_SUPPORT_HDP_LS |
 				RADEON_CG_SUPPORT_HDP_MGCG;
 			rdev->pg_flags = 0;
@@ -2683,8 +2686,8 @@ int radeon_asic_init(struct radeon_device *rdev)
 				RADEON_PG_SUPPORT_RLC_SMU_HS |
 				RADEON_PG_SUPPORT_SAMU;*/
 		}
-		rdev->has_uvd = true;
-		rdev->has_vce = true;
+		rdev->has_uvd = false;
+		rdev->has_vce = false;
 		break;
 	default:
 		/* FIXME: not supported yet */
@@ -2703,4 +2706,3 @@ int radeon_asic_init(struct radeon_device *rdev)
 
 	return 0;
 }
-
diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 770e31f5fd1b0c..4341b6c09f454d 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -336,8 +336,13 @@ int radeon_audio_init(struct radeon_device *rdev)
 
 	/* disable audio.  it will be set up later */
 	for (i = 0; i < rdev->audio.num_pins; i++)
+	{
 		radeon_audio_enable(rdev, &rdev->audio.pin[i], 0);
-
+		/* LVP has standalone S/PDIF on the third pin, always enable */
+		if (rdev->family == CHIP_LIVERPOOL) {
+			radeon_audio_enable(rdev, &rdev->audio.pin[i], 0xf);
+		}
+	}
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c
index 337d3a1c2a4099..b02ef1a33667d3 100644
--- a/drivers/gpu/drm/radeon/radeon_connectors.c
+++ b/drivers/gpu/drm/radeon/radeon_connectors.c
@@ -1553,6 +1553,29 @@ static const struct drm_connector_funcs radeon_dvi_connector_funcs = {
 	.force = radeon_dvi_force,
 };
 
+#ifdef CONFIG_X86_PS4
+int radeon_ps4_bridge_get_modes(struct drm_connector *connector);
+enum drm_connector_status radeon_ps4_bridge_detect(struct drm_connector *connector,
+					  bool force);
+int radeon_ps4_bridge_mode_valid(struct drm_connector *connector,
+			struct drm_display_mode *mode);
+
+static const struct drm_connector_helper_funcs radeon_ps4_dp_connector_helper_funcs = {
+	.get_modes = radeon_ps4_bridge_get_modes,
+	.mode_valid = radeon_ps4_bridge_mode_valid,
+	.best_encoder = radeon_dvi_encoder,
+};
+
+static const struct drm_connector_funcs radeon_ps4_dp_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = radeon_ps4_bridge_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	//.set_property = radeon_connector_set_property,
+	.destroy = radeon_connector_destroy,
+	.force = radeon_dvi_force,
+};
+
+#endif
 static int radeon_dp_get_modes(struct drm_connector *connector)
 {
 	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
@@ -1911,6 +1934,7 @@ radeon_add_atom_connector(struct drm_device *dev,
 	uint32_t subpixel_order = SubPixelNone;
 	bool shared_ddc = false;
 	bool is_dp_bridge = false;
+	bool is_ps4_bridge = false;
 	bool has_aux = false;
 
 	if (connector_type == DRM_MODE_CONNECTOR_Unknown)
@@ -1961,7 +1985,16 @@ radeon_add_atom_connector(struct drm_device *dev,
 	radeon_connector = kzalloc(sizeof(struct radeon_connector), GFP_KERNEL);
 	if (!radeon_connector)
 		return;
-
+	/* Liverpool (PS4) has an DP bridge which needs a special driver, and
+	 * a fake HDMI port that doesn't really exist. */
+	if (rdev->family == CHIP_LIVERPOOL) {
+		if (connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
+			is_dp_bridge = true;
+		} else {
+			return;
+		}
+	}
 	connector = &radeon_connector->base;
 
 	radeon_connector->connector_id = connector_id;
@@ -2017,10 +2050,17 @@ radeon_add_atom_connector(struct drm_device *dev,
 		case DRM_MODE_CONNECTOR_HDMIA:
 		case DRM_MODE_CONNECTOR_HDMIB:
 		case DRM_MODE_CONNECTOR_DisplayPort:
-			drm_connector_init(dev, &radeon_connector->base,
-					   &radeon_dp_connector_funcs, connector_type);
-			drm_connector_helper_add(&radeon_connector->base,
-						 &radeon_dp_connector_helper_funcs);
+ 			if (is_ps4_bridge) {
+ 				drm_connector_init(dev, &radeon_connector->base,
+ 						   &radeon_dp_connector_funcs, connector_type);
+ 				drm_connector_helper_add(&radeon_connector->base,
+ 							 &radeon_dp_connector_helper_funcs);
+ 			} else {
+ 				drm_connector_init(dev, &radeon_connector->base,
+ 						   &radeon_ps4_dp_connector_funcs, connector_type);
+ 				drm_connector_helper_add(&radeon_connector->base,
+ 							 &radeon_ps4_dp_connector_helper_funcs);
+ 			}
 			drm_object_attach_property(&radeon_connector->base.base,
 						      rdev->mode_info.underscan_property,
 						      UNDERSCAN_OFF);
diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c
index 58488eac846275..d69a1b2ad265bd 100644
--- a/drivers/gpu/drm/radeon/radeon_device.c
+++ b/drivers/gpu/drm/radeon/radeon_device.c
@@ -99,6 +99,7 @@ static const char radeon_family_name[][16] = {
 	"BONAIRE",
 	"KAVERI",
 	"KABINI",
+	"LIVERPOOL",
 	"HAWAII",
 	"MULLINS",
 	"LAST",
diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
index ddfe91efa61e4b..dabdfa8a832e9c 100644
--- a/drivers/gpu/drm/radeon/radeon_display.c
+++ b/drivers/gpu/drm/radeon/radeon_display.c
@@ -681,7 +681,7 @@ static void radeon_crtc_init(struct drm_device *dev, int index)
 	radeon_crtc->flip_queue = alloc_workqueue("radeon-crtc", WQ_HIGHPRI, 0);
 	rdev->mode_info.crtcs[index] = radeon_crtc;
 
-	if (rdev->family >= CHIP_BONAIRE) {
+	if (rdev->family >= CHIP_BONAIRE && rdev->family != CHIP_LIVERPOOL) {
 		radeon_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
 		radeon_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
 	} else {
diff --git a/drivers/gpu/drm/radeon/radeon_drv.c b/drivers/gpu/drm/radeon/radeon_drv.c
index f4becad0a78c0b..620274359044e7 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.c
+++ b/drivers/gpu/drm/radeon/radeon_drv.c
@@ -33,6 +33,10 @@
 #include <drm/radeon_drm.h>
 #include "radeon_drv.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #include <drm/drm_pciids.h>
 #include <linux/console.h>
 #include <linux/module.h>
@@ -353,7 +357,15 @@ static int radeon_pci_probe(struct pci_dev *pdev,
 	ret = radeon_kick_out_firmware_fb(pdev);
 	if (ret)
 		return ret;
-
+#ifdef CONFIG_X86_PS4
+	/* On the PS4 (Liverpool graphics) we have a hard dependency on the
+	 * Aeolia driver to set up the HDMI encoder which is connected to it,
+	 * so defer probe until it is ready. This test passes if this isn't
+	 * a PS4 (returns -ENODEV).
+	 */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	return drm_get_pci_dev(pdev, ent, &kms_driver);
 }
 
@@ -502,7 +514,7 @@ long radeon_drm_ioctl(struct file *filp,
 		return ret;
 
 	ret = drm_ioctl(filp, cmd, arg);
-	
+
 	pm_runtime_mark_last_busy(dev->dev);
 	pm_runtime_put_autosuspend(dev->dev);
 	return ret;
diff --git a/drivers/gpu/drm/radeon/radeon_encoders.c b/drivers/gpu/drm/radeon/radeon_encoders.c
index c6ee80216cf4a7..95e750454a539e 100644
--- a/drivers/gpu/drm/radeon/radeon_encoders.c
+++ b/drivers/gpu/drm/radeon/radeon_encoders.c
@@ -197,6 +197,21 @@ static void radeon_encoder_add_backlight(struct radeon_encoder *radeon_encoder,
 	}
 }
 
+#ifdef CONFIG_X86_PS4
+int radeon_ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder);
+
+static void radeon_maybe_add_bridge(struct drm_connector *connector,
+				    struct drm_encoder *encoder)
+{
+	struct drm_device *dev = connector->dev;
+	struct radeon_device *rdev = dev->dev_private;
+
+	if (rdev->family == CHIP_LIVERPOOL) {
+		radeon_ps4_bridge_register(connector, encoder);
+	}
+}
+#endif
 void
 radeon_link_encoder_connector(struct drm_device *dev)
 {
@@ -211,6 +226,9 @@ radeon_link_encoder_connector(struct drm_device *dev)
 		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 			radeon_encoder = to_radeon_encoder(encoder);
 			if (radeon_encoder->devices & radeon_connector->devices) {
+#ifdef CONFIG_X86_PS4
+				radeon_maybe_add_bridge(connector, encoder);
+#endif
 				drm_mode_connector_attach_encoder(connector, encoder);
 				if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
 					radeon_encoder_add_backlight(radeon_encoder, connector);
diff --git a/drivers/gpu/drm/radeon/radeon_family.h b/drivers/gpu/drm/radeon/radeon_family.h
index 4b7b87f71a6371..d69cd21f1b0bc5 100644
--- a/drivers/gpu/drm/radeon/radeon_family.h
+++ b/drivers/gpu/drm/radeon/radeon_family.h
@@ -96,6 +96,7 @@ enum radeon_family {
 	CHIP_BONAIRE,
 	CHIP_KAVERI,
 	CHIP_KABINI,
+	CHIP_LIVERPOOL,
 	CHIP_HAWAII,
 	CHIP_MULLINS,
 	CHIP_LAST,
diff --git a/drivers/gpu/drm/radeon/radeon_ib.c b/drivers/gpu/drm/radeon/radeon_ib.c
index 92ce0e533bc01b..2077eba7680f02 100644
--- a/drivers/gpu/drm/radeon/radeon_ib.c
+++ b/drivers/gpu/drm/radeon/radeon_ib.c
@@ -259,7 +259,7 @@ int radeon_ib_ring_tests(struct radeon_device *rdev)
 	unsigned i;
 	int r;
 
-	for (i = 0; i < RADEON_NUM_RINGS; ++i) {
+	for (i = 0; i < 1; ++i) { // RADEON_NUM_RINGS
 		struct radeon_ring *ring = &rdev->ring[i];
 
 		if (!ring->ready)
diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index 4b6542538ff915..e40798b7d7c79f 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
@@ -1503,6 +1503,7 @@ int radeon_pm_init(struct radeon_device *rdev)
 	case CHIP_BONAIRE:
 	case CHIP_KABINI:
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
 		/* DPM requires the RLC, RV770+ dGPU requires SMC */
diff --git a/drivers/gpu/drm/radeon/radeon_ucode.h b/drivers/gpu/drm/radeon/radeon_ucode.h
index dc4576e4d8ad16..4896ea0d25a40b 100644
--- a/drivers/gpu/drm/radeon/radeon_ucode.h
+++ b/drivers/gpu/drm/radeon/radeon_ucode.h
@@ -38,6 +38,8 @@
 #define CIK_PFP_UCODE_SIZE           2144
 #define CIK_ME_UCODE_SIZE            2144
 #define CIK_CE_UCODE_SIZE            2144
+#define LIVERPOOL_PFP_UCODE_SIZE     4192
+#define LIVERPOOL_ME_UCODE_SIZE      4192
 
 /* MEC */
 #define CIK_MEC_UCODE_SIZE           4192
@@ -53,6 +55,7 @@
 #define KB_RLC_UCODE_SIZE            2560
 #define KV_RLC_UCODE_SIZE            2560
 #define ML_RLC_UCODE_SIZE            2560
+#define LIVERPOOL_RLC_UCODE_SIZE     1536
 
 /* MC */
 #define BTC_MC_UCODE_SIZE            6024
diff --git a/drivers/gpu/drm/radeon/radeon_uvd.c b/drivers/gpu/drm/radeon/radeon_uvd.c
index 95f4db70dd2232..d0c4b728e2ffa3 100644
--- a/drivers/gpu/drm/radeon/radeon_uvd.c
+++ b/drivers/gpu/drm/radeon/radeon_uvd.c
@@ -124,6 +124,7 @@ int radeon_uvd_init(struct radeon_device *rdev)
 	case CHIP_BONAIRE:
 	case CHIP_KABINI:
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
 		legacy_fw_name = FIRMWARE_BONAIRE_LEGACY;
diff --git a/drivers/gpu/drm/radeon/radeon_vce.c b/drivers/gpu/drm/radeon/radeon_vce.c
index c1c619facb476a..1334a92a10f80b 100644
--- a/drivers/gpu/drm/radeon/radeon_vce.c
+++ b/drivers/gpu/drm/radeon/radeon_vce.c
@@ -76,6 +76,7 @@ int radeon_vce_init(struct radeon_device *rdev)
 	case CHIP_BONAIRE:
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
+	case CHIP_LIVERPOOL:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
 		fw_name = FIRMWARE_BONAIRE;
diff --git a/drivers/iommu/amd_iommu_init.c b/drivers/iommu/amd_iommu_init.c
index b97984a5ddad24..279e3783218c6c 100644
--- a/drivers/iommu/amd_iommu_init.c
+++ b/drivers/iommu/amd_iommu_init.c
@@ -2317,6 +2317,7 @@ static void __init free_iommu_resources(void)
 
 #endif
 }
+#ifndef CONFIG_X86_PS4 // TODO this should detect ps4-ness at runtime
 
 /* SB IOAPIC is always on this device in AMD systems */
 #define IOAPIC_SB_DEVID		((0x00 << 8) | PCI_DEVFN(0x14, 0))
@@ -2369,7 +2370,7 @@ static bool __init check_ioapic_information(void)
 
 	return ret;
 }
-
+#endif
 static void __init free_dma_resources(void)
 {
 	free_pages((unsigned long)amd_iommu_pd_alloc_bitmap,
@@ -2504,8 +2505,9 @@ static int __init early_amd_iommu_init(void)
 	if (!is_kdump_kernel() || amd_iommu_disabled)
 		disable_iommus();
 
-	if (amd_iommu_irq_remap)
+	/*if (amd_iommu_irq_remap)
 		amd_iommu_irq_remap = check_ioapic_information();
+		*/
 
 	if (amd_iommu_irq_remap) {
 		/*
diff --git a/drivers/mmc/host/sdhci-pci-core.c b/drivers/mmc/host/sdhci-pci-core.c
index 0e386f5cc83650..571ccadaab4c33 100644
--- a/drivers/mmc/host/sdhci-pci-core.c
+++ b/drivers/mmc/host/sdhci-pci-core.c
@@ -30,6 +30,10 @@
 #include <linux/mmc/sdhci-pci-data.h>
 #include <linux/acpi.h>
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #include "sdhci.h"
 #include "sdhci-pci.h"
 #include "sdhci-pci-o2micro.h"
@@ -249,6 +253,53 @@ static const struct sdhci_pci_fixes sdhci_cafe = {
 static const struct sdhci_pci_fixes sdhci_intel_qrk = {
 	.quirks		= SDHCI_QUIRK_NO_HISPD_BIT,
 };
+#ifdef CONFIG_X86_PS4
+static int aeolia_probe(struct sdhci_pci_chip *chip)
+{
+	chip->num_slots = 1;
+	chip->first_bar = 0;
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+
+	chip->pdev->class &= ~0x0000FF;
+	chip->pdev->class |= PCI_SDHCI_IFDMA;
+	return 0;
+}
+
+static int aeolia_probe_slot(struct sdhci_pci_slot *slot)
+{
+	int err = apcie_assign_irqs(slot->chip->pdev, 1);
+	if (err <= 0) {
+		dev_err(&slot->chip->pdev->dev, "failed to get IRQ: %d\n", err);
+		return -ENODEV;
+	}
+	slot->host->irq = slot->chip->pdev->irq;
+	return 0;
+}
+
+static void aeolia_remove_slot(struct sdhci_pci_slot *slot, int dead)
+{
+	apcie_free_irqs(slot->chip->pdev->irq, 1);
+}
+
+static int aeolia_enable_dma(struct sdhci_pci_slot *slot)
+{
+	if (pci_set_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
+		return -EINVAL;
+	}
+	if (pci_set_consistent_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static const struct sdhci_pci_fixes sdhci_aeolia = {
+	.probe		= aeolia_probe,
+	.probe_slot	= aeolia_probe_slot,
+	.remove_slot	= aeolia_remove_slot,
+	.enable_dma	= aeolia_enable_dma,
+};
+#endif
 
 static int mrst_hc_probe_slot(struct sdhci_pci_slot *slot)
 {
@@ -1039,6 +1090,7 @@ static const struct sdhci_pci_fixes sdhci_o2 = {
 #endif
 };
 
+
 static const struct sdhci_pci_fixes sdhci_jmicron = {
 	.probe		= jmicron_probe,
 
@@ -1365,9 +1417,16 @@ static const struct pci_device_id pci_ids[] = {
 	SDHCI_PCI_DEVICE(O2, SDS1,     o2),
 	SDHCI_PCI_DEVICE(O2, SEABIRD0, o2),
 	SDHCI_PCI_DEVICE(O2, SEABIRD1, o2),
+	//SDHCI_PCI_DEVICE(ARASAN, PHY_EMMC, arasan),
+#ifdef CONFIG_X86_PS4
+	SDHCI_PCI_DEVICE(SONY, AEOLIA_SDHCI, aeolia),
+	SDHCI_PCI_DEVICE(SONY, BELIZE_SDHCI, aeolia),
+	//SDHCI_PCI_DEVICE(SONY, BAIKAL_SDHCI, aeolia),
+#endif
 	SDHCI_PCI_DEVICE_CLASS(AMD, SYSTEM_SDHCI, PCI_CLASS_MASK, amd),
 	/* Generic SD host controller */
 	{PCI_DEVICE_CLASS(SYSTEM_SDHCI, PCI_CLASS_MASK)},
+
 	{ /* end: all zeroes */ },
 };
 
@@ -1396,6 +1455,10 @@ static int sdhci_pci_enable_dma(struct sdhci_host *host)
 
 	pci_set_master(pdev);
 
+ 	if (slot->chip->fixes && slot->chip->fixes->enable_dma) {
+ 		return slot->chip->fixes->enable_dma(slot);
+ 	}
+
 	return 0;
 }
 
@@ -1510,12 +1573,13 @@ static const struct dev_pm_ops sdhci_pci_pm_ops = {
 \*****************************************************************************/
 
 static struct sdhci_pci_slot *sdhci_pci_probe_slot(
-	struct pci_dev *pdev, struct sdhci_pci_chip *chip, int first_bar,
+	struct pci_dev *pdev, struct sdhci_pci_chip *chip,
 	int slotno)
 {
 	struct sdhci_pci_slot *slot;
 	struct sdhci_host *host;
-	int ret, bar = first_bar + slotno;
+	int ret, bar = chip->first_bar + slotno;
+	//int ret, bar = first_bar + slotno;
 	size_t priv_size = chip->fixes ? chip->fixes->priv_size : 0;
 
 	if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {
@@ -1749,6 +1813,7 @@ static int sdhci_pci_probe(struct pci_dev *pdev,
 		chip->allow_runtime_pm = chip->fixes->allow_runtime_pm;
 	}
 	chip->num_slots = slots;
+	chip->first_bar = first_bar;
 	chip->pm_retune = true;
 	chip->rpm_retune = true;
 
@@ -1763,7 +1828,8 @@ static int sdhci_pci_probe(struct pci_dev *pdev,
 	slots = chip->num_slots;	/* Quirk may have changed this */
 
 	for (i = 0; i < slots; i++) {
-		slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
+		slot = sdhci_pci_probe_slot(pdev, chip, i);
+		//slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
 		if (IS_ERR(slot)) {
 			for (i--; i >= 0; i--)
 				sdhci_pci_remove_slot(chip->slots[i]);
diff --git a/drivers/mmc/host/sdhci-pci.h b/drivers/mmc/host/sdhci-pci.h
index 3e8ea3e566f6ba..278fa524e64840 100644
--- a/drivers/mmc/host/sdhci-pci.h
+++ b/drivers/mmc/host/sdhci-pci.h
@@ -111,7 +111,7 @@ struct sdhci_pci_fixes {
 	int			(*probe_slot) (struct sdhci_pci_slot *);
 	int			(*add_host) (struct sdhci_pci_slot *);
 	void			(*remove_slot) (struct sdhci_pci_slot *, int);
-
+	int			(*enable_dma) (struct sdhci_pci_slot *);
 #ifdef CONFIG_PM_SLEEP
 	int			(*suspend) (struct sdhci_pci_chip *);
 	int			(*resume) (struct sdhci_pci_chip *);
@@ -152,6 +152,7 @@ struct sdhci_pci_chip {
 	const struct sdhci_pci_fixes *fixes;
 
 	int			num_slots;	/* Slots on controller */
+	int			first_bar;	/* First valid BAR */
 	struct sdhci_pci_slot	*slots[MAX_SLOTS]; /* Pointers to host slots */
 };
 
diff --git a/drivers/net/ethernet/marvell/sky2.c b/drivers/net/ethernet/marvell/sky2.c
index b12e3a4f94397c..909af3b4377296 100644
--- a/drivers/net/ethernet/marvell/sky2.c
+++ b/drivers/net/ethernet/marvell/sky2.c
@@ -49,6 +49,11 @@
 
 #include <asm/irq.h>
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#include "../../../ps4/aeolia.h"
+#endif
+
 #include "sky2.h"
 
 #define DRV_NAME		"sky2"
@@ -144,6 +149,9 @@ static const struct pci_device_id sky2_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4380) }, /* 88E8057 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4381) }, /* 88E8059 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4382) }, /* 88E8079 */
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_GBE) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_GBE) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_GBE) },
 	{ 0 }
 };
 
@@ -164,7 +172,7 @@ static int gm_phy_write(struct sky2_hw *hw, unsigned port, u16 reg, u16 val)
 
 	gma_write16(hw, port, GM_SMI_DATA, val);
 	gma_write16(hw, port, GM_SMI_CTRL,
-		    GM_SMI_CT_PHY_AD(PHY_ADDR_MARV) | GM_SMI_CT_REG_AD(reg));
+		    GM_SMI_CT_PHY_AD(hw->phy_addr) | GM_SMI_CT_REG_AD(reg));
 
 	for (i = 0; i < PHY_RETRIES; i++) {
 		u16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);
@@ -189,8 +197,9 @@ static int __gm_phy_read(struct sky2_hw *hw, unsigned port, u16 reg, u16 *val)
 {
 	int i;
 
-	gma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(PHY_ADDR_MARV)
-		    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);
+  gma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(hw->phy_addr)
+   		    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);
+
 
 	for (i = 0; i < PHY_RETRIES; i++) {
 		u16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);
@@ -1388,7 +1397,7 @@ static int sky2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 	switch (cmd) {
 	case SIOCGMIIPHY:
-		data->phy_id = PHY_ADDR_MARV;
+		data->phy_id = hw->phy_addr;
 
 		/* fallthru */
 	case SIOCGMIIREG: {
@@ -3248,7 +3257,23 @@ static void sky2_reset(struct sky2_hw *hw)
 	u16 status;
 	int i;
 	u32 hwe_mask = Y2_HWE_ALL_MASK;
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		u32 val1, val2;
+
+		sky2_write32(hw, 0x60, 0x32100);
+		sky2_write32(hw, 0x64, 6);
+		sky2_write32(hw, 0x68, 0x63b9c);
+		sky2_write32(hw, 0x6c, 0x300);
+		val1 = sky2_read32(hw, 0x158);
+		val2 = sky2_read32(hw, 0x160);
+		val1 &= ~0x33333333;
+		val2 &= ~0xCC00000;
+		sky2_write32(hw, 0x158, val1);
+		sky2_write32(hw, 0x160, val2);
+	}
+#endif
 	/* disable ASF */
 	if (hw->chip_id == CHIP_ID_YUKON_EX
 	    || hw->chip_id == CHIP_ID_YUKON_SUPR) {
@@ -3312,7 +3337,12 @@ static void sky2_reset(struct sky2_hw *hw)
 		/* enable MACSec clock gating */
 		sky2_pci_write32(hw, PCI_DEV_REG3, P_CLK_MACSEC_DIS);
 	}
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		; /* Do not perform phy resets on aeolia, it will hang */
+	} else
+  #endif
 	if (hw->chip_id == CHIP_ID_YUKON_OPT ||
 	    hw->chip_id == CHIP_ID_YUKON_PRM ||
 	    hw->chip_id == CHIP_ID_YUKON_OP_2) {
@@ -3597,7 +3627,7 @@ static int sky2_get_link_ksettings(struct net_device *dev,
 	u32 supported, advertising;
 
 	supported = sky2_supported_modes(hw);
-	cmd->base.phy_address = PHY_ADDR_MARV;
+	cmd->base.phy_address = hw->phy_addr;
 	if (sky2_is_copper(hw)) {
 		cmd->base.port = PORT_TP;
 		cmd->base.speed = sky2->speed;
@@ -4743,7 +4773,43 @@ static const struct net_device_ops sky2_netdev_ops[2] = {
 	.ndo_get_stats64	= sky2_get_stats,
   },
 };
+#ifdef CONFIG_X86_PS4
+/* NOTE: This region is no longer referenced by current ps4 x86 code. */
+/* However it still contains the mac address. */
+static void aeolia_get_mac_address(struct sky2_hw *hw, unsigned char *addr) {
+	u8 default_addr[ETH_ALEN] = { 0x52, 0x54, 0x00, 0xf0, 0xff, 0x0f };
+	unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(hw->pdev->devfn), AEOLIA_FUNC_ID_MEM);
+	struct pci_dev *mem_dev;
+	phys_addr_t bp_base;
+	void __iomem *bp;
+
+	memcpy(addr, default_addr, sizeof(default_addr));
+
+	mem_dev = pci_get_slot(hw->pdev->bus, mem_devfn);
+	if (!mem_dev) {
+		dev_err(&hw->pdev->dev, "sky2: could not get handle to mem device\n");
+		return;
+	}
+
+	bp_base = pci_resource_start(mem_dev, 5) + APCIE_SPM_BP_BASE;
+	if (!request_mem_region(bp_base, APCIE_SPM_BP_SIZE, "spm.bp")) {
+		dev_err(&hw->pdev->dev, "sky2: failed to request bootparam SPM region\n");
+		return;
+	}
+
+	bp = ioremap(bp_base, APCIE_SPM_BP_SIZE);
+	if (!bp) {
+		dev_err(&hw->pdev->dev, "sky2: failed to map bootparam portion of SPM\n");
+		goto release_bp;
+	}
+
+	memcpy_fromio(addr, bp, ETH_ALEN);
 
+	iounmap(bp);
+release_bp:
+	release_mem_region(bp_base, APCIE_SPM_BP_SIZE);
+}
+#endif
 /* Initialize network device */
 static struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,
 					   int highmem, int wol)
@@ -4815,7 +4881,12 @@ static struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,
 		dev->max_mtu = ETH_DATA_LEN;
 	else
 		dev->max_mtu = ETH_JUMBO_MTU;
-
+#ifdef CONFIG_X86_PS4
+	if (hw->pdev->vendor == PCI_VENDOR_ID_SONY) {
+		aeolia_get_mac_address(hw, dev->dev_addr);
+	} else
+#endif
+  {
 	/* try to get mac address in the following order:
 	 * 1) from device tree data
 	 * 2) from internal registers set by bootloader
@@ -4826,7 +4897,7 @@ static struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,
 	else
 		memcpy_fromio(dev->dev_addr, hw->regs + B2_MAC_1 + port * 8,
 			      ETH_ALEN);
-
+  }
 	/* if the address is invalid, use a random value */
 	if (!is_valid_ether_addr(dev->dev_addr)) {
 		struct sockaddr sa = { AF_UNSPEC };
@@ -4938,7 +5009,11 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	int err, using_dac = 0, wol_default;
 	u32 reg;
 	char buf1[16];
-
+#ifdef CONFIG_X86_PS4
+	/* This will return negative on non-PS4 platforms */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	err = pci_enable_device(pdev);
 	if (err) {
 		dev_err(&pdev->dev, "cannot enable PCI device\n");
@@ -4969,7 +5044,15 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 
 	pci_set_master(pdev);
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(31)) < 0 ||
+		    pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(31)) < 0) {
+			dev_err(&pdev->dev, "no usable DMA configuration\n");
+			goto err_out_free_regions;
+		}
+	} else
+#endif
 	if (sizeof(dma_addr_t) > sizeof(u32) &&
 	    !(err = pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))) {
 		using_dac = 1;
@@ -5017,7 +5100,15 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		dev_err(&pdev->dev, "cannot map device registers\n");
 		goto err_out_free_hw;
 	}
-
+  hw->phy_addr = PHY_ADDR_MARV;
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		/* aeolia supports some sort of "l2 switch" */
+		/* it has normal phy at addr 1 with a possibly-active switch at addr 2 */
+		hw->phy_addr = 1;
+	}
+#endif
 	err = sky2_init(hw);
 	if (err)
 		goto err_out_iounmap;
@@ -5041,7 +5132,18 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		err = -ENOMEM;
 		goto err_out_free_pci;
 	}
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    apcie_assign_irqs(pdev, 1) > 0) {
+		err = sky2_test_msi(hw);
+		if (err) {
+			apcie_free_irqs(pdev->irq, 1);
+			/* PS4 requires MSI, so if it fails, bail out. */
+			goto err_out_free_netdev;
+		}
+		hw->flags |= SKY2_HW_USE_AEOLIA_MSI;
+	} else
+#endif
 	if (!disable_msi && pci_enable_msi(pdev) == 0) {
 		err = sky2_test_msi(hw);
 		if (err) {
@@ -5098,6 +5200,11 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 err_out_unregister:
 	unregister_netdev(dev);
 err_out_free_netdev:
+#ifdef CONFIG_X86_PS4
+	if (hw->flags & SKY2_HW_USE_AEOLIA_MSI)
+		apcie_free_irqs(pdev->irq, 1);
+	else
+#endif
 	if (hw->flags & SKY2_HW_USE_MSI)
 		pci_disable_msi(pdev);
 	free_netdev(dev);
@@ -5144,7 +5251,11 @@ static void sky2_remove(struct pci_dev *pdev)
 		napi_disable(&hw->napi);
 		free_irq(pdev->irq, hw);
 	}
-
+  #ifdef CONFIG_X86_PS4
+  	if (hw->flags & SKY2_HW_USE_AEOLIA_MSI)
+  		apcie_free_irqs(pdev->irq, 1);
+  	else
+  #endif
 	if (hw->flags & SKY2_HW_USE_MSI)
 		pci_disable_msi(pdev);
 	pci_free_consistent(pdev, hw->st_size * sizeof(struct sky2_status_le),
diff --git a/drivers/net/ethernet/marvell/sky2.h b/drivers/net/ethernet/marvell/sky2.h
index b02b6523083ce9..f9433ce46bada1 100644
--- a/drivers/net/ethernet/marvell/sky2.h
+++ b/drivers/net/ethernet/marvell/sky2.h
@@ -2294,7 +2294,7 @@ struct sky2_hw {
 #define SKY2_HW_VLAN_BROKEN     0x00000200
 #define SKY2_HW_RSS_CHKSUM	0x00000400	/* RSS requires chksum */
 #define SKY2_HW_IRQ_SETUP	0x00000800
-
+#define SKY2_HW_USE_AEOLIA_MSI	0x00001000
 	u8	     	     chip_id;
 	u8		     chip_rev;
 	u8		     pmd_type;
@@ -2308,7 +2308,7 @@ struct sky2_hw {
 	struct timer_list    watchdog_timer;
 	struct work_struct   restart_work;
 	wait_queue_head_t    msi_wait;
-
+	u8		     phy_addr;
 	char		     irq_name[0];
 };
 
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e23bfd9845b12f..fac4f27ffaadac 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2199,6 +2199,9 @@ static int only_one_child(struct pci_bus *bus)
 	return 0;
 }
 
+// It can be arbitrary (above 2). Freebsd uses 20, so use that too.
+#define AEOLIA_SLOT_NUM 20
+
 /**
  * pci_scan_slot - scan a PCI slot on a bus for devices.
  * @bus: PCI bus to scan
@@ -2214,10 +2217,15 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 {
 	unsigned fn, nr = 0;
 	struct pci_dev *dev;
-
+	u32 l;
 	if (only_one_child(bus) && (devfn > 0))
 		return 0; /* Already scanned the entire slot */
-
+	// skip phantom Aeolia devices that bleed through the PCI space
+	if (PCI_SLOT(devfn) != AEOLIA_SLOT_NUM &&
+		pci_bus_read_dev_vendor_id(bus, devfn, &l, 60*1000) &&
+		(l & 0xffff) == PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
 	dev = pci_scan_single_device(bus, devfn);
 	if (!dev)
 		return 0;
@@ -2225,6 +2233,11 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 		nr++;
 
 	for (fn = next_fn(bus, dev, 0); fn > 0; fn = next_fn(bus, dev, fn)) {
+		if (PCI_SLOT(devfn) != AEOLIA_SLOT_NUM &&
+			pci_bus_read_dev_vendor_id(bus, devfn + fn, &l, 60*1000) &&
+			(l & 0xffff) == PCI_VENDOR_ID_SONY) {
+			continue;
+		}
 		dev = pci_scan_single_device(bus, devfn + fn);
 		if (dev) {
 			if (!dev->is_added)
diff --git a/drivers/ps4/Makefile b/drivers/ps4/Makefile
new file mode 100644
index 00000000000000..4f7d50363f501f
--- /dev/null
+++ b/drivers/ps4/Makefile
@@ -0,0 +1,9 @@
+# Aeolia PCI devices
+# LISTED IN INIT ORDER \o/ ...  ._.
+# N.B. this driver must be init'd before pretty much everything, but actual dependants are:
+# drivers/net/ethernet/marvell/sky2 (implements ps4-gbe)
+obj-y += ps4-apcie.o \
+	ps4-apcie-uart.o \
+	ps4-apcie-icc.o \
+	ps4-apcie-pwrbutton.o \
+	icc/i2c.o \
diff --git a/drivers/ps4/aeolia.h b/drivers/ps4/aeolia.h
new file mode 100644
index 00000000000000..13df4b9a4fef08
--- /dev/null
+++ b/drivers/ps4/aeolia.h
@@ -0,0 +1,172 @@
+#ifndef _AEOLIA_H
+#define _AEOLIA_H
+
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/i2c.h>
+
+enum aeolia_func_id {
+	AEOLIA_FUNC_ID_ACPI = 0,
+	AEOLIA_FUNC_ID_GBE,
+	AEOLIA_FUNC_ID_AHCI,
+	AEOLIA_FUNC_ID_SDHCI,
+	AEOLIA_FUNC_ID_PCIE,
+	AEOLIA_FUNC_ID_DMAC,
+	AEOLIA_FUNC_ID_MEM,
+	AEOLIA_FUNC_ID_XHCI,
+
+	AEOLIA_NUM_FUNCS
+};
+
+/* MSI registers for up to 31, but only 23 known. */
+#define APCIE_NUM_SUBFUNC		23
+
+/* Sub-functions, aka MSI vectors */
+enum apcie_subfunc {
+	APCIE_SUBFUNC_GLUE	= 0,
+	APCIE_SUBFUNC_ICC	= 3,
+	APCIE_SUBFUNC_HPET	= 5,
+	APCIE_SUBFUNC_SFLASH	= 11,
+	APCIE_SUBFUNC_RTC	= 13,
+	APCIE_SUBFUNC_UART0	= 19,
+	APCIE_SUBFUNC_UART1	= 20,
+	APCIE_SUBFUNC_TWSI	= 21,
+
+	APCIE_NUM_SUBFUNCS	= 23
+};
+
+#define APCIE_NR_UARTS 2
+
+/* Relative to BAR2 */
+#define APCIE_RGN_RTC_BASE		0x0
+#define APCIE_RGN_RTC_SIZE		0x1000
+
+#define APCIE_RGN_CHIPID_BASE		0x1000
+#define APCIE_RGN_CHIPID_SIZE		0x1000
+
+#define APCIE_REG_CHIPID_0		0x1104
+#define APCIE_REG_CHIPID_1		0x1108
+#define APCIE_REG_CHIPREV		0x110c
+
+/* Relative to BAR4 */
+#define APCIE_RGN_UART_BASE		0x140000
+#define APCIE_RGN_UART_SIZE		0x1000
+
+#define APCIE_RGN_PCIE_BASE		0x1c8000
+#define APCIE_RGN_PCIE_SIZE		0x1000
+
+#define APCIE_RGN_ICC_BASE		0x184000
+#define APCIE_RGN_ICC_SIZE		0x1000
+
+#define APCIE_REG_BAR(x)		(APCIE_RGN_PCIE_BASE + (x))
+#define APCIE_REG_BAR_MASK(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3))
+#define APCIE_REG_BAR_ADDR(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3) + 0x4)
+
+#define APCIE_REG_MSI(x)		(APCIE_RGN_PCIE_BASE + 0x400 + (x))
+#define APCIE_REG_MSI_CONTROL		APCIE_REG_MSI(0x0)
+#define APCIE_REG_MSI_MASK(func)	APCIE_REG_MSI(0x4c + ((func) << 2))
+#define APCIE_REG_MSI_DATA_HI(func)	APCIE_REG_MSI(0x8c + ((func) << 2))
+#define APCIE_REG_MSI_ADDR(func)	APCIE_REG_MSI(0xac + ((func) << 2))
+/* This register has non-uniform structure per function, dealt with in code */
+#define APCIE_REG_MSI_DATA_LO(off)	APCIE_REG_MSI(0x100 + (off))
+
+/* Not sure what the two individual bits do */
+#define APCIE_REG_MSI_CONTROL_ENABLE	0x05
+
+/* Enable for the entire function, 4 is special */
+#define APCIE_REG_MSI_MASK_FUNC		0x01000000
+#define APCIE_REG_MSI_MASK_FUNC4	0x80000000
+
+#define APCIE_REG_ICC(x)		(APCIE_RGN_ICC_BASE + (x))
+#define APCIE_REG_ICC_DOORBELL		APCIE_REG_ICC(0x804)
+#define APCIE_REG_ICC_STATUS		APCIE_REG_ICC(0x814)
+#define APCIE_REG_ICC_IRQ_MASK		APCIE_REG_ICC(0x824)
+
+/* Apply to both DOORBELL and STATUS */
+#define APCIE_ICC_SEND			0x01
+#define APCIE_ICC_ACK			0x02
+
+/* Relative to func6 BAR5 */
+#define APCIE_SPM_ICC_BASE		0x2c000
+#define APCIE_SPM_ICC_SIZE		0x1000
+
+/* Boot params passed from southbridge */
+#define APCIE_SPM_BP_BASE		0x2f000
+#define APCIE_SPM_BP_SIZE		0x20
+
+#define APCIE_SPM_ICC_REQUEST		0x0
+#define APCIE_SPM_ICC_REPLY		0x800
+
+#define ICC_REPLY 0x4000
+#define ICC_EVENT 0x8000
+
+#define ICC_MAGIC 0x42
+#define ICC_EVENT_MAGIC 0x24
+
+struct icc_message_hdr {
+	u8 magic;// not magic: it's ID of sender. 0x32=EAP,0x42=SoC(x86/fbsd)
+ 	u8 major;// service id (destination)
+ 	u16 minor;// message id (command)
+	u16 unknown;
+	u16 cookie; //normally monotonic xfer counter, can be set to special values
+	u16 length;
+	u16 checksum;
+} __packed;
+
+#define ICC_HDR_SIZE sizeof(struct icc_message_hdr)
+#define ICC_MIN_SIZE 0x20
+#define ICC_MAX_SIZE 0x7f0
+#define ICC_MIN_PAYLOAD (ICC_MIN_SIZE - ICC_HDR_SIZE)
+#define ICC_MAX_PAYLOAD (ICC_MAX_SIZE - ICC_HDR_SIZE)
+
+struct apcie_icc_dev {
+	phys_addr_t spm_base;
+	void __iomem *spm;
+
+	spinlock_t reply_lock;
+	bool reply_pending;
+
+	struct icc_message_hdr request;
+	struct icc_message_hdr reply;
+	u16 reply_extra_checksum;
+	void *reply_buffer;
+	int reply_length;
+	wait_queue_head_t wq;
+
+	struct i2c_adapter i2c;
+	struct input_dev *pwrbutton_dev;
+};
+
+struct apcie_dev {
+	struct pci_dev *pdev;
+	struct irq_domain *irqdomain;
+	void __iomem *bar0;
+	void __iomem *bar2;
+	void __iomem *bar4;
+
+	int nvec;
+	int serial_line[2];
+	struct apcie_icc_dev icc;
+};
+
+#define sc_err(...) dev_err(&sc->pdev->dev, __VA_ARGS__)
+#define sc_warn(...) dev_warn(&sc->pdev->dev, __VA_ARGS__)
+#define sc_notice(...) dev_notice(&sc->pdev->dev, __VA_ARGS__)
+#define sc_info(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_dbg(...) dev_dbg(&sc->pdev->dev, __VA_ARGS__)
+
+static inline int apcie_irqnum(struct apcie_dev *sc, int index)
+{
+	if (sc->nvec > 1) {
+		return sc->pdev->irq + index;
+	} else {
+		return sc->pdev->irq;
+	}
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+	    void *reply, u16 reply_length);
+
+#endif
diff --git a/drivers/ps4/icc/i2c.c b/drivers/ps4/icc/i2c.c
new file mode 100644
index 00000000000000..647c26a5cdd455
--- /dev/null
+++ b/drivers/ps4/icc/i2c.c
@@ -0,0 +1,156 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "../aeolia.h"
+
+#define ICC_MAX_READ_DATA 0xff
+#define ICC_MAX_WRITE_DATA 0xf8
+
+/* This is actually multiple nested variable length structures, but since we
+ * currently only support one op per transaction, we hardcode it. */
+struct icc_i2c_msg {
+	/* Header */
+	u8 code;
+	u16 length;
+	u8 count;
+	struct {
+		u8 major;
+		u8 length;
+		u8 minor;
+		u8 count;
+		struct {
+			u8 length;
+			u8 slave_addr;
+			u8 reg_addr;
+			u8 data[ICC_MAX_WRITE_DATA];
+		} xfer;
+	} cmd;
+} __packed;
+
+static int icc_i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
+			  unsigned short flags,
+			  char read_write, u8 command, int size,
+			  union i2c_smbus_data *data)
+{
+	struct apcie_dev *sc = i2c_get_adapdata(adapter);
+	int ret;
+	struct icc_i2c_msg msg;
+	u8 resultbuf[8 + ICC_MAX_READ_DATA];
+
+	msg.code = 4; /* Don't really know what this is */
+	msg.count = 1;
+	msg.cmd.count = 1;
+	msg.cmd.xfer.slave_addr = addr << 1;
+	msg.cmd.xfer.reg_addr = command;
+	if (read_write == I2C_SMBUS_READ) {
+		msg.cmd.major = 1;
+		msg.cmd.minor = 1;
+		msg.cmd.length = 8;
+		msg.cmd.xfer.data[0] = 0; /* unknown */
+	} else {
+		msg.cmd.major = 2;
+		msg.cmd.minor = 2;
+	}
+
+	switch (size) {
+	case I2C_SMBUS_BYTE_DATA:
+		msg.cmd.xfer.length = 1;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 8;
+			msg.cmd.xfer.data[0] = data->byte;
+		}
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		msg.cmd.xfer.length = 2;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 9;
+			msg.cmd.xfer.data[0] = data->word & 0xff;
+			msg.cmd.xfer.data[1] = data->word >> 8;
+		}
+		break;
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		msg.cmd.xfer.length = data->block[0];
+		if (read_write == I2C_SMBUS_WRITE) {
+			if (data->block[0] > ICC_MAX_WRITE_DATA) {
+				sc_err("icc-i2c: transaction too large: %d\n",
+				       data->block[0]);
+				return -E2BIG;
+			}
+			msg.cmd.length = 7 + data->block[0];
+			memcpy(msg.cmd.xfer.data, &data->block[1],
+			       data->block[0]);
+		}
+		break;
+	default:
+		sc_err("icc-i2c: unsupported transaction %d\n", size);
+		return -ENOTSUPP;
+	}
+
+	msg.length = msg.cmd.length + 4;
+	ret = apcie_icc_cmd(0x10, 0x0, &msg, msg.length, resultbuf,
+		      sizeof(resultbuf));
+	if (ret < 2 || ret > sizeof(resultbuf)) {
+		sc_err("icc-i2c: icc command failed: %d\n", ret);
+		return -EIO;
+	}
+	if (resultbuf[0] != 0 || resultbuf[1] != 0) {
+		sc_err("icc-i2c: i2c command failed: %d, %d\n",
+		       resultbuf[0], resultbuf[1]);
+		return -EIO;
+	}
+
+	if (read_write == I2C_SMBUS_READ)
+		switch (size) {
+		case I2C_SMBUS_BYTE_DATA:
+			data->byte = resultbuf[8];
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			data->word = resultbuf[8] | (resultbuf[9] << 8);
+			break;
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			memcpy(&data->block[1], &resultbuf[8],
+			       data->block[0]);
+			break;
+		}
+
+	return 0;
+}
+
+u32 icc_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+static const struct i2c_algorithm icc_i2c_algo = {
+	.smbus_xfer   = &icc_i2c_smbus_xfer,
+	.functionality = &icc_i2c_functionality,
+};
+
+
+int icc_i2c_init(struct apcie_dev *sc)
+{
+	struct i2c_adapter *i2c;
+	int ret;
+
+	i2c = &sc->icc.i2c;
+	i2c->owner = THIS_MODULE;
+	i2c->algo = &icc_i2c_algo;
+	i2c->algo_data = NULL;
+	i2c->dev.parent = &sc->pdev->dev;
+	strlcpy(i2c->name, "icc", sizeof(i2c->name));
+	i2c_set_adapdata(i2c, sc);
+	ret = i2c_add_adapter(i2c);
+	if (ret < 0) {
+		sc_err("failed to add i2c adapter\n");
+		return ret;
+	}
+	return 0;
+}
+
+void icc_i2c_remove(struct apcie_dev *sc)
+{
+	i2c_del_adapter(&sc->icc.i2c);
+}
diff --git a/drivers/ps4/ps4-apcie-icc.c b/drivers/ps4/ps4-apcie-icc.c
new file mode 100644
index 00000000000000..2ee9885d7a1cb0
--- /dev/null
+++ b/drivers/ps4/ps4-apcie-icc.c
@@ -0,0 +1,602 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <asm/ps4.h>
+#include "aeolia.h"
+
+/* There should normally be only one Aeolia device in a system. This allows
+ * other kernel code in unrelated subsystems to issue icc requests without
+ * having to get a reference to the device. */
+static struct apcie_dev *icc_sc;
+DEFINE_MUTEX(icc_mutex);
+
+/* The ICC message passing interface seems to be potentially designed to
+ * support multiple outstanding requests at once, but the original PS4 OS never
+ * does this, so we don't either. */
+
+#define BUF_FULL 0x7f0
+#define BUF_EMPTY 0x7f4
+#define HDR(x) (offsetof(struct icc_message_hdr, x))
+#define REQUEST (sc->icc.spm + APCIE_SPM_ICC_REQUEST)
+#define REPLY (sc->icc.spm + APCIE_SPM_ICC_REPLY)
+
+/* Seconds. Yes, some ICC requests can be slow. */
+int icc_timeout = 15;
+
+int icc_i2c_init(struct apcie_dev *sc);
+void icc_i2c_remove(struct apcie_dev *sc);
+int icc_pwrbutton_init(struct apcie_dev *sc);
+void icc_pwrbutton_remove(struct apcie_dev *sc);
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state);
+
+#define ICC_MAJOR	'I'
+
+ struct icc_cmd {
+ 	u8 major;
+ 	u16 minor;
+ 	void __user *data;
+ 	u16 length;
+ 	void __user *reply;
+ 	u16 reply_length;
+ };
+
+#define ICC_IOCTL_CMD _IOWR(ICC_MAJOR, 1, struct icc_cmd)
+
+static u16 checksum(const void *p, int length)
+{
+	const u8 *pp = p;
+	u16 sum = 0;
+	while (length--)
+		sum += *pp++;
+	return sum;
+}
+
+static void dump_message(struct apcie_dev *sc, int offset)
+{
+	int len;
+	struct icc_message_hdr hdr;
+	memcpy_fromio(&hdr, sc->icc.spm + offset, ICC_HDR_SIZE);
+
+	sc_err("icc: hdr: [%02x] %02x:%04x unk %x #%d len %d cksum 0x%x\n",
+	       hdr.magic, hdr.major, hdr.minor, hdr.unknown, hdr.cookie,
+	       hdr.length, hdr.checksum);
+	len = min(hdr.length - ICC_HDR_SIZE, ICC_MAX_PAYLOAD);
+	if (len > 0) {
+		sc_err("icc: data:");
+		while (len--)
+			printk(" %02x", ioread8(sc->icc.spm + (offset++) +
+			                         ICC_HDR_SIZE));
+		printk("\n");
+	}
+}
+
+static void handle_event(struct apcie_dev *sc, struct icc_message_hdr *msg)
+{
+	switch ((msg->major << 16) | msg->minor) {
+		case 0x088010:
+			icc_pwrbutton_trigger(sc, 1);
+			break;
+		case 0x088011:
+			icc_pwrbutton_trigger(sc, 0);
+			break;
+		default:
+			sc_err("icc: event arrived, not yet supported.\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			break;
+	}
+}
+
+static void handle_message(struct apcie_dev *sc)
+{
+	u32 rep_empty, rep_full;
+	int off, copy_size;
+	struct icc_message_hdr msg;
+
+	rep_empty = ioread32(REPLY + BUF_EMPTY);
+	rep_full = ioread32(REPLY + BUF_FULL);
+
+	if (rep_empty != 0 || rep_full != 1) {
+		sc_err("icc: reply buffer in bad state (%d, %d)\n",
+			rep_empty, rep_full);
+		return;
+	}
+
+	memcpy_fromio(&msg, REPLY, ICC_HDR_SIZE);
+
+	if (msg.minor & ICC_EVENT) {
+		if (msg.magic != ICC_EVENT_MAGIC) {
+			sc_err("icc: event has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		handle_event(sc, &msg);
+	} else if (msg.minor & ICC_REPLY) {
+		if (msg.magic != ICC_MAGIC) {
+			sc_err("icc: reply has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		spin_lock(&sc->icc.reply_lock);
+		if (!sc->icc.reply_pending) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: unexpected reply\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.cookie != sc->icc.request.cookie) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad cookie %d\n", msg.cookie);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.length < ICC_HDR_SIZE || msg.length > ICC_MAX_SIZE) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad length %d\n", msg.length);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		off = ICC_HDR_SIZE;
+		copy_size = min(sc->icc.reply_length,
+				(int)(msg.length - off));
+		memcpy_fromio(sc->icc.reply_buffer, REPLY + off, copy_size);
+		off += copy_size;
+		sc->icc.reply_extra_checksum = 0;
+		while (off < msg.length)
+			sc->icc.reply_extra_checksum += ioread8(REPLY + off++);
+		sc->icc.reply_pending = false;
+		sc->icc.reply_length = copy_size;
+		sc->icc.reply = msg;
+		spin_unlock(&sc->icc.reply_lock);
+		wake_up(&sc->icc.wq);
+	} else {
+		sc_err("icc: unknown message arrived\n");
+		dump_message(sc, APCIE_SPM_ICC_REPLY);
+	}
+}
+
+static irqreturn_t icc_interrupt(int irq, void *arg)
+{
+	struct apcie_dev *sc = arg;
+	u32 status;
+	u32 ret = IRQ_NONE;
+
+	do {
+		status = ioread32(sc->bar4 + APCIE_REG_ICC_STATUS);
+
+		if (status & APCIE_ICC_ACK) {
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			ret = IRQ_HANDLED;
+		}
+
+		if (status & APCIE_ICC_SEND) {
+			iowrite32(APCIE_ICC_SEND,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			handle_message(sc);
+			iowrite32(0, REPLY + BUF_FULL);
+			iowrite32(1, REPLY + BUF_EMPTY);
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_DOORBELL);
+			ret = IRQ_HANDLED;
+		}
+	} while (status);
+
+	return ret;
+}
+
+static int _apcie_icc_cmd(struct apcie_dev *sc, u8 major, u16 minor, const void *data,
+		    u16 length, void *reply, u16 reply_length, bool intr)
+{
+	int ret;
+	u32 req_empty, req_full;
+	u16 rep_checksum;
+
+	if (length > ICC_MAX_PAYLOAD)
+		return -E2BIG;
+
+	sc->icc.request.magic = ICC_MAGIC;
+	sc->icc.request.major = major;
+	sc->icc.request.minor = minor;
+	sc->icc.request.cookie++;
+	sc->icc.request.length = ICC_HDR_SIZE + length;
+	sc->icc.request.checksum = 0;
+	if (sc->icc.request.length < ICC_MIN_SIZE)
+		sc->icc.request.length = ICC_MIN_SIZE;
+
+	sc->icc.request.checksum = checksum(&sc->icc.request, ICC_HDR_SIZE);
+	sc->icc.request.checksum += checksum(data, length);
+	sc->icc.reply_buffer = reply;
+	sc->icc.reply_length = reply_length;
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		return -EIO;
+	}
+
+	iowrite32(0, REQUEST + BUF_EMPTY);
+
+	memcpy_toio(REQUEST, &sc->icc.request, ICC_HDR_SIZE);
+	memcpy_toio(REQUEST + ICC_HDR_SIZE, data, length);
+	if (length < ICC_MIN_PAYLOAD)
+		memset_io(REQUEST + ICC_HDR_SIZE + length, 0,
+			  ICC_MIN_PAYLOAD - length);
+
+	iowrite32(1, REQUEST + BUF_FULL);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_pending = true;
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	iowrite32(APCIE_ICC_SEND, sc->bar4 + APCIE_REG_ICC_DOORBELL);
+
+	if (intr)
+		ret = wait_event_interruptible_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+	else
+		ret = wait_event_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_buffer = NULL;
+	if (ret < 0 || sc->icc.reply_pending) { /* interrupted or timed out */
+		sc->icc.reply_pending = false;
+		spin_unlock_irq(&sc->icc.reply_lock);
+		sc_err("icc: interrupted or timeout: ret = %d\n", ret);
+		return ret < 0 ? -EINTR : -ETIMEDOUT;
+	}
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	rep_checksum = sc->icc.reply.checksum;
+	sc->icc.reply.checksum = 0;
+	rep_checksum -= checksum(&sc->icc.reply, ICC_HDR_SIZE);
+	rep_checksum -= checksum(reply, sc->icc.reply_length);
+	rep_checksum -= sc->icc.reply_extra_checksum;
+
+	if (rep_checksum) {
+		sc_err("icc: checksum mismatch (diff: %x)\n", rep_checksum);
+		return -EIO;
+	}
+
+	if (sc->icc.reply.major != major ) {
+		sc_err("icc: major mismatch\n");
+		return -EIO;
+	}
+	if (sc->icc.reply.minor != (minor | ICC_REPLY) ) {
+		sc_err("icc: minor mismatch\n");
+		return -EIO;
+	}
+
+	return sc->icc.reply.length - ICC_HDR_SIZE;
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+		   void *reply, u16 reply_length)
+{
+	int ret;
+
+	mutex_lock(&icc_mutex);
+	if (!icc_sc) {
+		pr_err("icc: not ready\n");
+		return -EAGAIN;
+	}
+	ret = _apcie_icc_cmd(icc_sc, major, minor, data, length, reply, reply_length,
+		       false);
+	mutex_unlock(&icc_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(apcie_icc_cmd);
+
+void resetUsbPort(void)
+{
+	u8 off = 0, on = 1;
+	u8 resp[20];
+	int ret;
+	
+	//Turn OFF Usb
+	ret = apcie_icc_cmd(5, 0x10, &off, sizeof(off), resp, 20);
+	printk("Turn OFF USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off USB failed!");
+		return;
+	}
+	
+	//Turn ON Usb
+	ret = apcie_icc_cmd(5, 0x10, &on, sizeof(on), resp, 20);
+	printk("Turn ON USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on USB failed");
+		return;
+	}
+}
+
+void resetBtWlan(void)
+{
+	u8 off = 2, on = 3;
+	u8 resp[20];
+	int ret;
+	
+
+	/* Get bt/wlan status */
+//	ret = apcie_icc_cmd(5, 1, NULL, 0, resp, 20);
+//	printk("BT/WLAN status: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+
+	/** Turn off is done from linux-loader actually, if you want you can remove it from linux-loader and done it here **/
+	
+	//Turn OFF bt/wlan
+/*	ret = apcie_icc_cmd(5, 0, &off, sizeof(off), resp, 20);
+	printk("Turn OFF BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off bt/wlan failed!");
+		return;
+	}
+*/
+
+	//Turn ON bt/wlan
+	ret = apcie_icc_cmd(5, 0, &on, sizeof(on), resp, 20);
+	printk("Turn ON BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on bt/wlan failed");
+		return;
+	}
+}
+
+void do_icc_init(void) {
+	u8 svc = 0x10;
+	u8 reply[0x30];
+	static const u8 led_config[] = {
+		3, 1, 0, 0,
+			0x10, 1, /* Blue: on */
+				2, 0xff, 2, 1, 0x00,
+			0x11, 1, /* White: off */
+				2, 0x00, 2, 1, 0x00,
+			0x02, 3, /* Orange: delay and pulse, loop forever */
+				1, 0x00, 4, 1, 0xbf,
+				2, 0xff, 5, 1, 0xff,
+				2, 0x00, 5, 1, 0xff,
+	};
+	int ret;
+	// test: get FW version
+	ret = apcie_icc_cmd(2, 6, NULL, 0, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+	ret = apcie_icc_cmd(1, 0, &svc, 1, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+
+	/* Set the LED to something nice */
+	ret = apcie_icc_cmd(9, 0x20, led_config, ARRAY_SIZE(led_config), reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+}
+
+static void icc_shutdown(void)
+{
+	uint8_t command[] = {
+		0, 0, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+void icc_reboot(void)
+{
+	uint8_t command[] = {
+		0, 1, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+static void *ioctl_tmp_buf = NULL;
+
+ static long icc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ {
+ 	int ret;
+ 	void __user *uap = (void __user *)arg;
+ 	switch (cmd) {
+ 	case ICC_IOCTL_CMD: {
+ 		struct icc_cmd cmd;
+ 		int reply_len;
+ 		ret = copy_from_user(&cmd, uap, sizeof(cmd));
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = copy_from_user(ioctl_tmp_buf, cmd.data, cmd.length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		reply_len = apcie_icc_cmd(cmd.major, cmd.minor, ioctl_tmp_buf,
+ 			cmd.length, ioctl_tmp_buf, cmd.reply_length);
+ 		if (reply_len < 0) {
+ 			ret = reply_len;
+ 			break;
+ 		}
+ 		ret = copy_to_user(cmd.reply, ioctl_tmp_buf, cmd.reply_length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = reply_len;
+ 		} break;
+ 	default:
+ 		ret = -ENOENT;
+ 		break;
+ 	}
+ 	return ret;
+ }
+
+ static const struct file_operations icc_fops = {
+ 	.owner = THIS_MODULE,
+ 	.unlocked_ioctl = icc_ioctl,
+ };
+
+
+int apcie_icc_init(struct apcie_dev *sc)
+{
+	int ret;
+	unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(sc->pdev->devfn), AEOLIA_FUNC_ID_MEM);
+	struct pci_dev *mem_dev;
+	u32 req_empty, req_full;
+
+	/* ICC makes use of a segment of SPM memory, available via a different
+	 * PCI function in Aeolia, so we need to get a handle to it. */
+	mem_dev = pci_get_slot(sc->pdev->bus, mem_devfn);
+	if (!mem_dev) {
+		sc_err("icc: could not get handle to mem device\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE,
+				"apcie.icc")) {
+		sc_err("icc: failed to request ICC register region\n");
+		return -EBUSY;
+	}
+
+	sc->icc.spm_base = pci_resource_start(mem_dev, 5) + APCIE_SPM_ICC_BASE;
+	if (!request_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE,
+				"spm.icc")) {
+		sc_err("icc: failed to request ICC SPM region\n");
+		ret = -EBUSY;
+		goto release_icc;
+	}
+
+	sc->icc.spm = ioremap(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	if (!sc->icc.spm) {
+		sc_err("icc: failed to map ICC portion of SPM\n");
+		ret = -EIO;
+		goto release_spm;
+	}
+
+	spin_lock_init(&sc->icc.reply_lock);
+	init_waitqueue_head(&sc->icc.wq);
+
+	/* Clear flags */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_STATUS);
+
+	ret = request_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC),
+			  icc_interrupt, IRQF_SHARED, "icc", sc);
+	if (ret) {
+		sc_err("icc: could not request IRQ: %d\n", ret);
+		goto iounmap;
+	}
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		ret = -EIO;
+		goto free_irq;
+	}
+
+	mutex_lock(&icc_mutex);
+	icc_sc = sc;
+
+	/* Enable IRQs */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	mutex_unlock(&icc_mutex);
+
+	ret = icc_i2c_init(sc);
+	if (ret) {
+		sc_err("icc: i2c init failed: %d\n", ret);
+		goto unassign_global;
+	}
+	
+	resetBtWlan();
+//	resetUsbPort();
+	
+	ret = icc_pwrbutton_init(sc);
+	/* Not fatal */
+	if (ret)
+		sc_err("icc: pwrbutton init failed: %d\n", ret);
+
+	do_icc_init();
+	pm_power_off = &icc_shutdown;
+
+	ioctl_tmp_buf = kzalloc(1 << 16, GFP_KERNEL);
+ 	if (!ioctl_tmp_buf) {
+ 		sc_err("icc: alloc ioctl_tmp_buf failed\n");
+ 		goto done;
+ 	}
+ 	ret = register_chrdev(ICC_MAJOR, "icc", &icc_fops);
+ 	if (ret) {
+ 		sc_err("icc: register_chrdev failed: %d\n", ret);
+ 		goto done;
+ 	}
+ done:
+
+	return 0;
+
+unassign_global:
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+free_irq:
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+iounmap:
+	iounmap(sc->icc.spm);
+release_spm:
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+release_icc:
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+	return ret;
+}
+
+void apcie_icc_remove(struct apcie_dev *sc)
+{
+	sc_err("apcie_icc_remove: shouldn't normally be called\n");
+	pm_power_off = NULL;
+	icc_pwrbutton_remove(sc);
+	icc_i2c_remove(sc);
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+	iounmap(sc->icc.spm);
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+}
+
+#ifdef CONFIG_PM
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+}
+
+void apcie_icc_resume(struct apcie_dev *sc)
+{
+}
+#endif
diff --git a/drivers/ps4/ps4-apcie-pwrbutton.c b/drivers/ps4/ps4-apcie-pwrbutton.c
new file mode 100644
index 00000000000000..d695221703b5a2
--- /dev/null
+++ b/drivers/ps4/ps4-apcie-pwrbutton.c
@@ -0,0 +1,69 @@
+#include <linux/input.h>
+#include "aeolia.h"
+
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state)
+{
+	if (sc->icc.pwrbutton_dev) {
+		input_report_key(sc->icc.pwrbutton_dev, KEY_POWER, state ? 1 : 0);
+		input_sync(sc->icc.pwrbutton_dev);
+	}
+}
+
+int icc_pwrbutton_init(struct apcie_dev *sc)
+{
+	int ret = 0;
+	u16 button;
+	struct input_dev *dev;
+
+	dev = input_allocate_device();
+	if (!dev) {
+		sc_err("%s: Not enough memory.\n", __func__);
+		return -ENOMEM;
+	}
+
+	set_bit(EV_KEY, dev->evbit);
+	set_bit(KEY_POWER, dev->keybit);
+
+	dev->name = "Power Button";
+	dev->id.bustype = BUS_HOST;
+
+	/* this makes the button look like an acpi power button
+	 * no clue whether anyone relies on that though */
+	dev->id.product = 0x02;
+	dev->phys = "LNXPWRBN/button/input0";
+
+	dev->dev.parent = &sc->pdev->dev;
+	ret = input_register_device(dev);
+	if (ret) {
+		sc_err("%s: Failed to register device\n", __func__);
+		input_free_device(dev);
+		return ret;
+	}
+
+	sc->icc.pwrbutton_dev = dev;
+
+	// enable power button notifications
+	button = 0x100;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable power notifications (%d)\n",
+			__func__, ret);
+	}
+
+	// enable reset button notifications (?)
+	button = 0x102;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable reset notifications (%d)\n",
+		        __func__, ret);
+	}
+
+	return 0;
+}
+
+void icc_pwrbutton_remove(struct apcie_dev *sc)
+{
+	if (sc->icc.pwrbutton_dev)
+		input_free_device(sc->icc.pwrbutton_dev);
+	sc->icc.pwrbutton_dev = NULL;
+}
diff --git a/drivers/ps4/ps4-apcie-uart.c b/drivers/ps4/ps4-apcie-uart.c
new file mode 100644
index 00000000000000..6dd6dc195735a5
--- /dev/null
+++ b/drivers/ps4/ps4-apcie-uart.c
@@ -0,0 +1,67 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "aeolia.h"
+
+void apcie_uart_remove(struct apcie_dev *sc);
+
+int apcie_uart_init(struct apcie_dev *sc)
+{
+	int i;
+	struct uart_8250_port uart;
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		sc->serial_line[i] = -1;
+	}
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		uint32_t off = APCIE_RGN_UART_BASE + (i << 12);
+		memset(&uart, 0, sizeof(uart));
+		uart.port.irq		= apcie_irqnum(sc, APCIE_SUBFUNC_UART0 + i);
+		uart.port.uartclk	= 58500000;
+		uart.port.flags		= UPF_SHARE_IRQ;
+		uart.port.iotype	= UPIO_MEM32;
+		uart.port.mapbase	= pci_resource_start(sc->pdev, 4) + off;
+		uart.port.membase	= sc->bar4 + off;
+		uart.port.regshift	= 2;
+		uart.port.dev		= &sc->pdev->dev;
+
+		sc->serial_line[i] = serial8250_register_8250_port(&uart);
+		if (sc->serial_line[i] < 0) {
+			sc_err("Failed to register serial port %d\n", i);
+			apcie_uart_remove(sc);
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
+void apcie_uart_remove(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		if (sc->serial_line[i] >= 0) {
+			serial8250_unregister_port(sc->serial_line[i]);
+			sc->serial_line[i] = -1;
+		}
+	}
+}
+
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_suspend_port(sc->serial_line[i]);
+}
+
+void apcie_uart_resume(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_resume_port(sc->serial_line[i]);
+}
+#endif
diff --git a/drivers/ps4/ps4-apcie.c b/drivers/ps4/ps4-apcie.c
new file mode 100644
index 00000000000000..bec9b3ad3420b1
--- /dev/null
+++ b/drivers/ps4/ps4-apcie.c
@@ -0,0 +1,534 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/msi.h>
+#include <asm/irqdomain.h>
+#include <asm/irq_remapping.h>
+
+#include <asm/msi.h>
+
+#include <asm/ps4.h>
+
+#include "aeolia.h"
+
+/* #define QEMU_HACK_NO_IOMMU */
+
+/* Number of implemented MSI registers per function */
+static const int subfuncs_per_func[AEOLIA_NUM_FUNCS] = {
+	4, 4, 4, 4, 31, 2, 2, 4
+};
+
+static inline u32 glue_read32(struct apcie_dev *sc, u32 offset) {
+	return ioread32(sc->bar4 + offset);
+}
+
+static inline void glue_write32(struct apcie_dev *sc, u32 offset, u32 value) {
+	iowrite32(value, sc->bar4 + offset);
+}
+
+static inline void glue_set_region(struct apcie_dev *sc, u32 func, u32 bar,
+			    u32 base, u32 mask) {
+	glue_write32(sc, APCIE_REG_BAR_MASK(func, bar), mask);
+	glue_write32(sc, APCIE_REG_BAR_ADDR(func, bar), base);
+}
+
+static inline void glue_set_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) | mask, ptr);
+}
+
+static inline void glue_clear_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) & ~mask, ptr);
+}
+
+static inline void glue_mask_and_set(struct apcie_dev *sc, u32 offset, u32 mask, u32 set) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32((ioread32(ptr) & ~mask) | set, ptr);
+}
+
+static void apcie_config_msi(struct apcie_dev *sc, u32 func, u32 subfunc,
+			     u32 addr, u32 data) {
+	u32 offset;
+
+	sc_dbg("apcie_config_msi: func: %u, subfunc: %u, addr %08x data: 0x%08x (%u)\n",
+		func, subfunc, addr, data, data);
+
+	glue_clear_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0x8), 0xffffffff);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xc + (func << 2)), 0xB7FFFF00 + func * 16);
+	glue_write32(sc, APCIE_REG_MSI_ADDR(func), addr);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xcc + (func << 2)), 0);
+	glue_write32(sc, APCIE_REG_MSI_DATA_HI(func), data & 0xffe0);
+
+	if (func < 4) {
+		/* First 4 functions have 4 IRQs/subfuncs each */
+		offset = (func << 4) | (subfunc << 2);
+	} else if (func == 4) {
+		/* Function 4 gets 24 consecutive slots,
+		 * then 7 more at the end. */
+		if (subfunc < 24)
+			offset = 0x40 + (subfunc << 2);
+		else
+			offset = 0xe0 + ((subfunc - 24) << 2);
+	} else {
+		offset = 0xa0 + ((func - 5) << 4) + (subfunc << 2);
+	}
+	glue_write32(sc, APCIE_REG_MSI_DATA_LO(offset), data & 0x1f);
+
+	if (func == AEOLIA_FUNC_ID_PCIE)
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC4);
+	else
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC);
+
+	glue_set_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+}
+
+static void apcie_msi_write_msg(struct irq_data *data, struct msi_msg *msg)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	/* Linux likes to unconfigure MSIs like this, but since we share the
+	 * address between subfunctions, we can't do that. The IRQ should be
+	 * masked via apcie_msi_mask anyway, so just do nothing. */
+	if (!msg->address_lo) {
+		return;
+	}
+
+	sc_dbg("apcie_msi_write_msg(%08x, %08x) mask=0x%x irq=%d hwirq=0x%lx %p\n",
+	       msg->address_lo, msg->data, data->mask, data->irq, data->hwirq, sc);
+
+	if (subfunc == 0xff) {
+		int i;
+		for (i = 0; i < subfuncs_per_func[func]; i++)
+			apcie_config_msi(sc, func, i, msg->address_lo, msg->data);
+	} else {
+		apcie_config_msi(sc, func, subfunc, msg->address_lo, msg->data);
+	}
+}
+
+static void apcie_msi_unmask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_set_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_mask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_clear_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_calc_mask(struct irq_data *data) {
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	if (subfunc == 0xff) {
+		data->mask = (1 << subfuncs_per_func[func]) - 1;
+	} else {
+		data->mask = 1 << subfunc;
+	}
+}
+
+static struct irq_chip apcie_msi_controller = {
+	.name = "Aeolia-MSI",
+	.irq_unmask = apcie_msi_unmask,
+	.irq_mask = apcie_msi_mask,
+	.irq_ack = irq_chip_ack_parent,
+	.irq_set_affinity = msi_domain_set_affinity,
+	.irq_retrigger = irq_chip_retrigger_hierarchy,
+	.irq_compose_msi_msg = irq_msi_compose_msg,
+	.irq_write_msi_msg = apcie_msi_write_msg,
+	.flags = IRQCHIP_SKIP_SET_WAKE,
+};
+
+static irq_hw_number_t apcie_msi_get_hwirq(struct msi_domain_info *info,
+					  msi_alloc_info_t *arg)
+{
+	return arg->msi_hwirq;
+}
+
+static int apcie_msi_init(struct irq_domain *domain,
+			 struct msi_domain_info *info, unsigned int virq,
+			 irq_hw_number_t hwirq, msi_alloc_info_t *arg)
+{
+	struct irq_data *data;
+	pr_devel("apcie_msi_init(%p, %p, %d, 0x%lx, %p)\n", domain, info, virq, hwirq, arg);
+
+	data = irq_domain_get_irq_data(domain, virq);
+	irq_domain_set_info(domain, virq, hwirq, info->chip, info->chip_data,
+			    handle_edge_irq, NULL, "edge");
+	apcie_msi_calc_mask(data);
+	return 0;
+}
+
+static void apcie_msi_free(struct irq_domain *domain,
+			  struct msi_domain_info *info, unsigned int virq)
+{
+	pr_devel("apcie_msi_free(%d)\n", virq);
+}
+
+static struct msi_domain_ops apcie_msi_domain_ops = {
+	.get_hwirq	= apcie_msi_get_hwirq,
+	.msi_init	= apcie_msi_init,
+	.msi_free	= apcie_msi_free,
+};
+
+static struct msi_domain_info apcie_msi_domain_info = {
+	.flags		= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS,
+	.ops		= &apcie_msi_domain_ops,
+	.chip		= &apcie_msi_controller,
+	.handler	= handle_edge_irq,
+};
+
+struct irq_domain *apcie_create_irq_domain(struct apcie_dev *sc)
+{
+	struct irq_domain *parent;
+	struct irq_alloc_info info;
+
+	sc_dbg("apcie_create_irq_domain\n");
+	if (x86_vector_domain == NULL)
+		return NULL;
+
+	apcie_msi_domain_info.chip_data = (void *)sc;
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_MSI;
+	info.msi_dev = sc->pdev;
+	parent = irq_remapping_get_ir_irq_domain(&info);
+	if (parent == NULL) {
+		parent = x86_vector_domain;
+	} else {
+		apcie_msi_domain_info.flags |= MSI_FLAG_MULTI_PCI_MSI;
+		apcie_msi_controller.name = "IR-Aeolia-MSI";
+	}
+
+	return msi_create_irq_domain(NULL, &apcie_msi_domain_info, parent);
+}
+
+static int apcie_is_compatible_device(struct pci_dev *dev)
+{
+	if (!dev || dev->vendor != PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
+	return (dev->device == PCI_DEVICE_ID_SONY_AEOLIA_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BELIZE_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BAIKAL_PCIE);
+}
+
+int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	int ret;
+	unsigned int sc_devfn;
+	struct pci_dev *sc_dev;
+	struct apcie_dev *sc;
+	struct irq_alloc_info info;
+
+	sc_devfn = (dev->devfn & ~7) | AEOLIA_FUNC_ID_PCIE;
+	sc_dev = pci_get_slot(dev->bus, sc_devfn);
+
+	if (!apcie_is_compatible_device(sc_dev)) {
+		dev_err(&dev->dev, "apcie: this is not an Aeolia device\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+	sc = pci_get_drvdata(sc_dev);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie: not ready yet, cannot assign IRQs\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_MSI;
+	/* IRQs "come from" function 4 as far as the IOMMU/system see */
+	info.msi_dev = sc->pdev;
+	/* Our hwirq number is function << 8 plus subfunction.
+	 * Subfunction is usually 0 and implicitly increments per hwirq,
+	 * but can also be 0xff to indicate that this is a shared IRQ. */
+	info.msi_hwirq = PCI_FUNC(dev->devfn) << 8;
+
+	dev_dbg(&dev->dev, "apcie_assign_irqs(%d)\n", nvec);
+
+#ifndef QEMU_HACK_NO_IOMMU
+	info.flags = X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
+	if (!(apcie_msi_domain_info.flags & MSI_FLAG_MULTI_PCI_MSI)) {
+		nvec = 1;
+		info.msi_hwirq |= 0xff; /* Shared IRQ for all subfunctions */
+	}
+#endif
+
+	ret = irq_domain_alloc_irqs(sc->irqdomain, nvec, NUMA_NO_NODE, &info);
+	if (ret >= 0) {
+		dev->irq = ret;
+		ret = nvec;
+	}
+
+fail:
+	dev_dbg(&dev->dev, "apcie_assign_irqs returning %d\n", ret);
+	if (sc_dev)
+		pci_dev_put(sc_dev);
+	return ret;
+}
+EXPORT_SYMBOL(apcie_assign_irqs);
+
+void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs)
+{
+	irq_domain_free_irqs(virq, nr_irqs);
+}
+EXPORT_SYMBOL(apcie_free_irqs);
+
+static void apcie_glue_remove(struct apcie_dev *sc);
+
+static int apcie_glue_init(struct apcie_dev *sc)
+{
+	int i;
+
+	sc_info("apcie glue probe\n");
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE,
+				"apcie.glue")) {
+		sc_err("Failed to request pcie region\n");
+		return -EBUSY;
+
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 2) +
+				APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE,
+				"apcie.chipid")) {
+		sc_err("Failed to request chipid region\n");
+		release_mem_region(pci_resource_start(sc->pdev, 4) +
+				   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+		return -EBUSY;
+	}
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_PCIE, 2, 0xbf018000, 0x7fff);
+
+	sc_info("Aeolia chip revision: %08x:%08x:%08x\n",
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_0),
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_1),
+		ioread32(sc->bar2 + APCIE_REG_CHIPREV));
+
+	/* Mask all MSIs first, to avoid spurious IRQs */
+	for (i = 0; i < AEOLIA_NUM_FUNCS; i++) {
+		glue_write32(sc, APCIE_REG_MSI_MASK(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_ADDR(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_DATA_HI(i), 0);
+	}
+
+	for (i = 0; i < 0xfc; i += 4)
+		glue_write32(sc, APCIE_REG_MSI_DATA_LO(i), 0);
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_GBE, 0, 0xbfa00000, 0x3fff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_AHCI, 5, 0xbfa04000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 0, 0xbfa80000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 0, 0xbfa05000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 2, 0xbfa06000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 2, 0xc0000000, 0x3fffffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 0, 0xbf400000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 2, 0xbf600000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 4, 0xbf800000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 5, 0, 0);
+
+	sc->irqdomain = apcie_create_irq_domain(sc);
+	if (!sc->irqdomain) {
+		sc_err("Failed to create IRQ domain");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc->nvec = apcie_assign_irqs(sc->pdev, APCIE_NUM_SUBFUNC);
+	if (sc->nvec <= 0) {
+		sc_err("Failed to assign IRQs");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc_dbg("dev->irq=%d\n", sc->pdev->irq);
+
+	return 0;
+}
+
+static void apcie_glue_remove(struct apcie_dev *sc) {
+	sc_info("apcie glue remove\n");
+
+	if (sc->nvec > 0) {
+		apcie_free_irqs(sc->pdev->irq, sc->nvec);
+		sc->nvec = 0;
+	}
+	if (sc->irqdomain) {
+		irq_domain_remove(sc->irqdomain);
+		sc->irqdomain = NULL;
+	}
+	release_mem_region(pci_resource_start(sc->pdev, 2) +
+			   APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+}
+
+#ifdef CONFIG_PM
+static int apcie_glue_suspend(struct apcie_dev *sc, pm_message_t state) {
+	return 0;
+}
+
+static int apcie_glue_resume(struct apcie_dev *sc) {
+	return 0;
+}
+#endif
+
+
+int apcie_uart_init(struct apcie_dev *sc);
+int apcie_icc_init(struct apcie_dev *sc);
+void apcie_uart_remove(struct apcie_dev *sc);
+void apcie_icc_remove(struct apcie_dev *sc);
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_uart_resume(struct apcie_dev *sc);
+void apcie_icc_resume(struct apcie_dev *sc);
+#endif
+
+/* From arch/x86/platform/ps4/ps4.c */
+extern bool apcie_initialized;
+
+static int apcie_probe(struct pci_dev *dev, const struct pci_device_id *id) {
+	struct apcie_dev *sc;
+	int ret;
+
+	dev_dbg(&dev->dev, "apcie_probe()\n");
+
+	ret = pci_enable_device(dev);
+	if (ret) {
+		dev_err(&dev->dev,
+			"apcie_probe(): pci_enable_device failed: %d\n", ret);
+		return ret;
+	}
+
+	sc = kzalloc(sizeof(*sc), GFP_KERNEL);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie_probe(): alloc sc failed\n");
+		ret = -ENOMEM;
+		goto disable_dev;
+	}
+	sc->pdev = dev;
+	pci_set_drvdata(dev, sc);
+
+	// eMMC ... unused?
+	sc->bar0 = pci_ioremap_bar(dev, 0);
+	// pervasive 0
+	sc->bar2 = pci_ioremap_bar(dev, 2);
+	// pervasive 1 - misc peripherals
+	sc->bar4 = pci_ioremap_bar(dev, 4);
+
+	if (!sc->bar0 || !sc->bar2 || !sc->bar4) {
+		sc_err("failed to map some BARs, bailing out\n");
+		ret = -EIO;
+		goto free_bars;
+	}
+
+	if ((ret = apcie_glue_init(sc)) < 0)
+		goto free_bars;
+	if ((ret = apcie_uart_init(sc)) < 0)
+		goto remove_glue;
+	if ((ret = apcie_icc_init(sc)) < 0)
+		goto remove_uart;
+
+	apcie_initialized = true;
+	return 0;
+
+remove_uart:
+	apcie_uart_remove(sc);
+remove_glue:
+	apcie_glue_remove(sc);
+free_bars:
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+disable_dev:
+	pci_disable_device(dev);
+	return ret;
+}
+
+static void apcie_remove(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_remove(sc);
+	apcie_uart_remove(sc);
+	apcie_glue_remove(sc);
+
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+	pci_disable_device(dev);
+}
+
+#ifdef CONFIG_PM
+static int apcie_suspend(struct pci_dev *dev, pm_message_t state) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_suspend(sc, state);
+	apcie_uart_suspend(sc, state);
+	apcie_glue_suspend(sc, state);
+	return 0;
+}
+
+static int apcie_resume(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_resume(sc);
+	apcie_glue_resume(sc);
+	apcie_uart_resume(sc);
+	return 0;
+}
+#endif
+
+static const struct pci_device_id apcie_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_PCIE), },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, apcie_pci_tbl);
+
+static struct pci_driver apcie_driver = {
+	.name		= "aeolia_pcie",
+	.id_table	= apcie_pci_tbl,
+	.probe		= apcie_probe,
+	.remove		= apcie_remove,
+#ifdef CONFIG_PM
+	.suspend	= apcie_suspend,
+	.resume		= apcie_resume,
+#endif
+};
+module_pci_driver(apcie_driver);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 92b19721b595e5..399bccc78524f9 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -78,6 +78,13 @@ config USB_XHCI_TEGRA
 	---help---
 	  Say 'Y' to enable the support for the xHCI host controller
 	  found in NVIDIA Tegra124 and later SoCs.
+		
+config USB_XHCI_AEOLIA
+	tristate "xHCI support for Sony PS4 (Aeolia)"
+	depends on X86_PS4
+	---help---
+	  Say 'Y' to enable the support for the xHCI host controller
+	  found in the Sony PlayStation 4.
 
 endif # USB_XHCI_HCD
 
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 4ab2689c8952be..f4e52551d0ce35 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -68,6 +68,7 @@ obj-$(CONFIG_USB_XHCI_PCI)	+= xhci-pci.o
 obj-$(CONFIG_USB_XHCI_PLATFORM) += xhci-plat-hcd.o
 obj-$(CONFIG_USB_XHCI_MTK)	+= xhci-mtk.o
 obj-$(CONFIG_USB_XHCI_TEGRA)	+= xhci-tegra.o
+obj-$(CONFIG_USB_XHCI_AEOLIA)	+= xhci-aeolia.o
 obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
diff --git a/drivers/usb/host/xhci-aeolia.c b/drivers/usb/host/xhci-aeolia.c
new file mode 100644
index 00000000000000..6bc0cb03ceb376
--- /dev/null
+++ b/drivers/usb/host/xhci-aeolia.c
@@ -0,0 +1,304 @@
+/*
+ * xhci-aeoliat.c - xHCI host controller driver for Aeolia (Sony PS4)
+ *
+ * Borrows code from xhci-pci.c, hcd-pci.c, and xhci-plat.c.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <asm/ps4.h>
+
+#include "xhci.h"
+
+static const char hcd_name[] = "xhci_aeolia";
+
+static struct hc_driver __read_mostly xhci_aeolia_hc_driver;
+
+#define NR_DEVICES 3
+
+struct aeolia_xhci {
+	int nr_irqs;
+	struct usb_hcd *hcd[NR_DEVICES];
+};
+
+static int xhci_aeolia_setup(struct usb_hcd *hcd);
+
+static const struct xhci_driver_overrides xhci_aeolia_overrides __initconst = {
+	.extra_priv_size = sizeof(struct xhci_hcd),
+	.reset = xhci_aeolia_setup,
+};
+
+static void xhci_aeolia_quirks(struct device *dev, struct xhci_hcd *xhci)
+{
+	/*
+	 * Do not try to enable MSIs, we provide the MSIs ourselves
+	 * Do not touch DMA mask, we need a custom one
+	 */
+	xhci->quirks |= XHCI_PLAT | XHCI_PLAT_DMA;
+}
+
+/* called during probe() after chip reset completes */
+static int xhci_aeolia_setup(struct usb_hcd *hcd)
+{
+	return xhci_gen_setup(hcd, xhci_aeolia_quirks);
+}
+
+static int xhci_aeolia_probe_one(struct pci_dev *dev, int index)
+{
+	int retval;
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+	struct hc_driver *driver = &xhci_aeolia_hc_driver;
+	struct usb_hcd *hcd;
+	struct xhci_hcd *xhci;
+	int irq = (axhci->nr_irqs > 1) ? (dev->irq + index) : dev->irq;
+
+	// ok...adding this printk appears to have introduced a delay that fixed
+	// bringup of the middle host controller, so w/e for now...
+	
+	printk("xhci_aeolia_probe_one %d, controller is %x\n", index, dev->device);
+
+	hcd = usb_create_hcd(driver, &dev->dev, pci_name(dev));
+	pci_set_drvdata(dev, axhci); /* usb_create_hcd clobbers this */
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = pci_resource_start(dev, 2 * index);
+	hcd->rsrc_len = pci_resource_len(dev, 2 * index);
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+			driver->description)) {
+		dev_dbg(&dev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto put_hcd;
+	}
+	hcd->regs = pci_ioremap_bar(dev, 2 * index);
+	if (hcd->regs == NULL) {
+		dev_dbg(&dev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto release_mem_region;
+	}
+
+	device_wakeup_enable(hcd->self.controller);
+
+	xhci = hcd_to_xhci(hcd);
+	xhci->main_hcd = hcd;
+	xhci->shared_hcd = usb_create_shared_hcd(driver, &dev->dev,
+			pci_name(dev), hcd);
+	if (!xhci->shared_hcd) {
+		retval = -ENOMEM;
+		goto unmap_registers;
+	}
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto put_usb3_hcd;
+
+	retval = usb_add_hcd(xhci->shared_hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto dealloc_usb2_hcd;
+
+	axhci->hcd[index] = hcd;
+
+	return 0;
+
+dealloc_usb2_hcd:
+	usb_remove_hcd(hcd);
+put_usb3_hcd:
+	usb_put_hcd(xhci->shared_hcd);
+unmap_registers:
+	iounmap(hcd->regs);
+release_mem_region:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+put_hcd:
+	usb_put_hcd(hcd);
+	dev_err(&dev->dev, "init %s(%d) fail, %d\n",
+			pci_name(dev), index, retval);
+	return retval;
+}
+
+static void xhci_aeolia_remove_one(struct pci_dev *dev, int index)
+{
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+	struct usb_hcd *hcd = axhci->hcd[index];
+	struct xhci_hcd *xhci;
+
+	if (!hcd)
+		return;
+	xhci = hcd_to_xhci(hcd);
+
+	usb_remove_hcd(xhci->shared_hcd);
+	usb_remove_hcd(hcd);
+	usb_put_hcd(xhci->shared_hcd);
+	usb_put_hcd(hcd);
+	axhci->hcd[index] = NULL;
+}
+
+
+static int xhci_aeolia_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int idx;
+	int retval;
+	struct aeolia_xhci *axhci;
+
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+
+	if (pci_enable_device(dev) < 0)
+		return -ENODEV;
+
+	axhci = kzalloc(sizeof(*axhci), GFP_KERNEL);
+	if (!axhci) {
+		retval = -ENOMEM;
+		goto disable_device;
+	}
+	pci_set_drvdata(dev, axhci);
+
+	axhci->nr_irqs = retval = apcie_assign_irqs(dev, NR_DEVICES);
+	if (retval < 0) {
+		goto free_axhci;
+	}
+
+	pci_set_master(dev);
+
+	if (pci_set_dma_mask(dev, DMA_BIT_MASK(31)) ||
+		pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(31))) {
+		return -ENODEV;
+	}
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+ 		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) 
+			continue;
+		retval = xhci_aeolia_probe_one(dev, idx);
+		if (retval)
+			goto remove_hcds;
+	}
+
+	return 0;
+
+remove_hcds:
+	while (idx--)
+		xhci_aeolia_remove_one(dev, idx);
+	apcie_free_irqs(dev->irq, axhci->nr_irqs);
+free_axhci:
+	kfree(axhci);
+disable_device:
+	pci_disable_device(dev);
+	return retval;
+}
+
+static void xhci_aeolia_remove(struct pci_dev *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI) {
+			if(idx != 1)
+				xhci_aeolia_remove_one(dev, idx);
+		}
+		else
+			xhci_aeolia_remove_one(dev, idx);
+	}
+	
+	apcie_free_irqs(dev->irq, axhci->nr_irqs);
+	kfree(axhci);
+	pci_disable_device(dev);
+}
+
+
+static const struct pci_device_id pci_ids[] = {
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_XHCI) },
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_XHCI) },
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_XHCI) },
+	{ /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE(pci, pci_ids);
+
+#ifdef CONFIG_PM_SLEEP
+static int xhci_aeolia_suspend(struct device *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = dev_get_drvdata(dev);
+	struct xhci_hcd	*xhci;
+	int retval;
+	struct pci_dev		*pdev = to_pci_dev(dev);
+	
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1)
+			continue;
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		retval = xhci_suspend(xhci, device_may_wakeup(dev));
+		if (retval < 0)
+			goto resume;
+	}
+	return 0;
+
+resume:
+	while (idx--) {
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		xhci_resume(xhci, 0);
+	}
+	return retval;
+}
+
+static int xhci_aeolia_resume(struct device *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = dev_get_drvdata(dev);
+	struct xhci_hcd	*xhci;
+	int retval;
+	struct pci_dev		*pdev = to_pci_dev(dev);
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+ 		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) 
+			continue;		
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		retval = xhci_resume(xhci, 0);
+		if (retval < 0)
+			return retval;
+	}
+	return 0;
+}
+
+static const struct dev_pm_ops xhci_aeolia_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xhci_aeolia_suspend, xhci_aeolia_resume)
+};
+#endif
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct pci_driver xhci_aeolia_driver = {
+	.name =		"xhci_aeolia",
+	.id_table =	pci_ids,
+
+	.probe =	xhci_aeolia_probe,
+	.remove =	xhci_aeolia_remove,
+	/* suspend and resume implemented later */
+
+	.shutdown = 	usb_hcd_pci_shutdown,
+#ifdef CONFIG_PM_SLEEP
+	.driver = {
+		.pm = &xhci_aeolia_pm_ops
+	},
+#endif
+};
+
+static int __init xhci_aeolia_init(void)
+{
+	xhci_init_driver(&xhci_aeolia_hc_driver, &xhci_aeolia_overrides);
+	return pci_register_driver(&xhci_aeolia_driver);
+}
+module_init(xhci_aeolia_init);
+
+static void __exit xhci_aeolia_exit(void)
+{
+	pci_unregister_driver(&xhci_aeolia_driver);
+}
+module_exit(xhci_aeolia_exit);
+
+MODULE_DESCRIPTION("xHCI Aeolia Host Controller Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 930eecd864299f..cadf183a34c4b9 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -4967,22 +4967,23 @@ int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
 
 	/* Set dma_mask and coherent_dma_mask to 64-bits,
 	 * if xHC supports 64-bit addressing */
-	if (HCC_64BIT_ADDR(xhci->hcc_params) &&
-			!dma_set_mask(dev, DMA_BIT_MASK(64))) {
-		xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
-		dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
-	} else {
-		/*
-		 * This is to avoid error in cases where a 32-bit USB
-		 * controller is used on a 64-bit capable system.
-		 */
-		retval = dma_set_mask(dev, DMA_BIT_MASK(32));
-		if (retval)
-			return retval;
-		xhci_dbg(xhci, "Enabling 32-bit DMA addresses.\n");
-		dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+ 	if (!(xhci->quirks & XHCI_PLAT_DMA)) {
+		if (HCC_64BIT_ADDR(xhci->hcc_params) &&
+				!dma_set_mask(dev, DMA_BIT_MASK(64))) {
+			xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
+			dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
+		} else {
+			/*
+			 * This is to avoid error in cases where a 32-bit USB
+			 * controller is used on a 64-bit capable system.
+			 */
+			retval = dma_set_mask(dev, DMA_BIT_MASK(32));
+			if (retval)
+				return retval;
+			xhci_dbg(xhci, "Enabling 32-bit DMA addresses.\n");
+			dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+		}
 	}
-
 	xhci_dbg(xhci, "Calling HCD init\n");
 	/* Initialize HCD and host controller data structures. */
 	retval = xhci_init(hcd);
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cbc91536e5127d..e724184f7a5b1c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1840,6 +1840,7 @@ struct xhci_hcd {
 #define XHCI_INTEL_USB_ROLE_SW	BIT_ULL(31)
 #define XHCI_RESET_PLL_ON_DISCONNECT	BIT_ULL(34)
 #define XHCI_SNPS_BROKEN_SUSPEND    BIT_ULL(35)
+#define XHCI_PLAT_DMA		BIT_ULL(36)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 7fa3f1498b340a..60cc79fe0a54fe 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -868,6 +868,30 @@
 #define PCI_DEVICE_ID_TI_DRA72x		0xb501
 
 #define PCI_VENDOR_ID_SONY		0x104d
+#define PCI_DEVICE_ID_SONY_AEOLIA_ACPI	0x908f
+#define PCI_DEVICE_ID_SONY_AEOLIA_GBE	0x909e
+#define PCI_DEVICE_ID_SONY_AEOLIA_AHCI	0x909f
+#define PCI_DEVICE_ID_SONY_AEOLIA_SDHCI	0x90a0
+#define PCI_DEVICE_ID_SONY_AEOLIA_PCIE	0x90a1
+#define PCI_DEVICE_ID_SONY_AEOLIA_DMAC	0x90a2
+#define PCI_DEVICE_ID_SONY_AEOLIA_MEM	0x90a3
+#define PCI_DEVICE_ID_SONY_AEOLIA_XHCI	0x90a4
+#define PCI_DEVICE_ID_SONY_BELIZE_ACPI	0x90c8
+#define PCI_DEVICE_ID_SONY_BELIZE_GBE	0x90c9
+#define PCI_DEVICE_ID_SONY_BELIZE_AHCI	0x90ca
+#define PCI_DEVICE_ID_SONY_BELIZE_SDHCI	0x90cb
+#define PCI_DEVICE_ID_SONY_BELIZE_PCIE	0x90cc
+#define PCI_DEVICE_ID_SONY_BELIZE_DMAC	0x90cd
+#define PCI_DEVICE_ID_SONY_BELIZE_MEM	0x90ce
+#define PCI_DEVICE_ID_SONY_BELIZE_XHCI	0x90cf
+#define PCI_DEVICE_ID_SONY_BAIKAL_ACPI	0x90d7
+#define PCI_DEVICE_ID_SONY_BAIKAL_GBE	0x90d8
+#define PCI_DEVICE_ID_SONY_BAIKAL_AHCI	0x90d9
+#define PCI_DEVICE_ID_SONY_BAIKAL_SDHCI	0x90da
+#define PCI_DEVICE_ID_SONY_BAIKAL_PCIE	0x90db
+#define PCI_DEVICE_ID_SONY_BAIKAL_DMAC	0x90dc
+#define PCI_DEVICE_ID_SONY_BAIKAL_MEM	0x90dd
+#define PCI_DEVICE_ID_SONY_BAIKAL_XHCI	0x90de
 
 /* Winbond have two vendor IDs! See 0x10ad as well */
 #define PCI_VENDOR_ID_WINBOND2		0x1050

